<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tokamako</title>
    <link>https://huanglei.rocks/</link>
    <description>Recent content on Tokamako</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
    <lastBuildDate>Sat, 05 Mar 2022 15:44:33 +0800</lastBuildDate><atom:link href="https://huanglei.rocks/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Apache Parquet 格式简介</title>
      <link>https://huanglei.rocks/posts/parquet/</link>
      <pubDate>Sat, 05 Mar 2022 15:44:33 +0800</pubDate>
      
      <guid>https://huanglei.rocks/posts/parquet/</guid>
      <description>简介 Parquet 是一种面向列的数据存储格式，在 Hadoop 生态中使用广泛。Parquet 文件是不可变的，如果需要修改，只能通过 rewrite 的方式实现。
数据 layout 一个 Parquet 文件的数据布局如下图所示。需要注意的是，官网上的这个图并没有包含 index pages。
 官方的格式图    原始行格式的数据    Parquet 数据的遍历顺序    使用 Parquet 转换之后的格式   在 Parquet 中，数据每隔若干行被分作一个 row group；在同一个 row group 中，不同 row 的相同列被连续存储在一起。连续的列再间隔若干行会被分割为一个页（page）。
元数据 从如上的 Parquet 格式可以看出来，一个 Parquet 文件是包含了一些元数据的，比如 footer、page header 等等，这些元数据可以在读取 parquet 文件的时候提供相关信息来加速遍历。
Footer Footer 是整个 Parquet 文件的元数据，从 footer 可以得到文件的版本、数据 schema、row group 的元数据、row group 中的每一列的元数据等等。
Footer 位于 Parquet 的末尾，因此可以从文件结尾 seek 到倒数第 8 到倒数第 4 字节，作为 footer 的长度，从而得到 footer 区的起始 offset。</description>
    </item>
    
    <item>
      <title>BookKeeper 笔记</title>
      <link>https://huanglei.rocks/posts/bookkeeper-note/</link>
      <pubDate>Thu, 24 Feb 2022 01:18:35 +0800</pubDate>
      
      <guid>https://huanglei.rocks/posts/bookkeeper-note/</guid>
      <description>BookKeeper 的使用场景  WAL：比如 HDFS Namenode 的 EditLog（要求高可靠） 分布式存储：比如 Pulsar 的消息存储、DistributedLog 等  核心理念  通过条带化写（Data Striping）实现数据的多副本，所有存储节点角色对等； 通过其他的存储组件（ZooKeeper）实现元数据高可靠，故障恢复（recover）流程强依赖 ZK 的元数据；  也可以选用其他的存储服务，要求 1. CP 系统；2. 提供 CAS 原语   基于 RocksDB 提供 (ledger, sequence) -&amp;gt; (file, physicalOffset) 的索引（SingleDirectoryDbLedgerStorage#ledgerIndex）； 同一时刻只有一个 writer 和多个 reader，通过 fencing 机制避免出现多 writer，避免 sequence 乱序； 读写分离，冷热分离（tailing read/catch-up read）提高吞吐；  BookKeeper 的术语  ledger：一写多读的 append-only 文件，ledger 的最小数据单元是 fragment； bookie：存储 ledger 的节点； ledger has many records， called：entry，每个entry都有一个 sequence number，可以根据 ledger + seq 来读取一部分 entry。 quorum：几个 bookie 组成一个 quorum，通过复制提高可用性。 data striping：数据块交织写入到各个设备，提高写入的性能。类似 RAID1 的机制。   BookKeeper 的 quorum write 机制   Striping 很容易就会导致读取者所看到的 log 不一致，因此 BK 引入了 ZK 去保存元数据，并且通过 triming 机制（BK 称为 reader-initiated ledger recovery）来确保末尾未完整写完整个 quorum 的数据能够被安全删除并且对 reader 不可见。</description>
    </item>
    
    <item>
      <title>LSM Tree 笔记</title>
      <link>https://huanglei.rocks/posts/note-on-lsmt/</link>
      <pubDate>Thu, 10 Feb 2022 22:34:39 +0800</pubDate>
      
      <guid>https://huanglei.rocks/posts/note-on-lsmt/</guid>
      <description>写入（Write path）   先从磁盘（HDD）写入的特性引入 append-only 的 WAL。
  对于 KV 结构，如果写入是 append only的，那么就需要合并，不然读取性能太差。
  单文件合并性能差，因此需要按阈值切分为多个小文件，通过归并排序的思路优化合并的效率。
  多路归并要求每个文件有序，为了保证每个文件有序，就需要，数据写入的时候，不直接把 operation 直接写入到磁盘，而是先在内存缓存一段时间，并且在内存排好序，然后再一次把整个文件 flush 到磁盘。
 内存有序的数据结构：跳表、红黑树、B+ 树 buffer 在内存的数据丢了怎么办？先写 redo log    有序数据结构  RocksDB 的数据结构比较：选择跳表的原因是跳表支持并发插入。
 LSMT 的数据分类
 内存数据：MemTable 磁盘数据：SSTable（Sorted Sequence Table） 日志：redo log  内存数据组织 内存的数据需要保证有序，同时支持高性能的插入和查找。
 ART：自适应基树（比如 Bitcask 采用）； SkipList：LevelDB、RocksDB 等。  SSTable 文件格式 按 Block 进行存储，可以参考 LevelDB 和 RocksDB 的 SST 文件的格式。</description>
    </item>
    
    <item>
      <title>使用 GitHub Issue 作为 Hugo 的评论系统</title>
      <link>https://huanglei.rocks/posts/hugo-comment-with-github-issues/</link>
      <pubDate>Thu, 10 Feb 2022 15:07:10 +0800</pubDate>
      
      <guid>https://huanglei.rocks/posts/hugo-comment-with-github-issues/</guid>
      <description>安装 Octomments 按照 Octomments 的介绍，将 Octomments 安装到您的 GitHub 账户，确保它拥有访问您的目标 repo 的 issue 的权限。
配置 GitHub issue 在配置文件中增加配置项：
 comment.owner：Issue repo 的拥有者 comment.repo：Issue repo 的名字  配置 Comment 组件 在您的博客站点根目录下的layouts/partials/comments.html 模板中增加：
{{ if .Params.issueNumber -}} &amp;lt;link href=&amp;#34;https://unpkg.com/octomments/build/ocs-ui.min.css&amp;#34; rel=&amp;#34;stylesheet&amp;#34;&amp;gt; &amp;lt;div id=&amp;#34;comments&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;script src=&amp;#34;https://unpkg.com/octomments/build/ocs.min.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;script&amp;gt; Octomments({ github: { owner: &amp;#39;{{ $.Site.Params.comment.owner }}&amp;#39;, repo: &amp;#39;{{ $.Site.Params.comment.repo }}&amp;#39;, }, issueNumber: {{ .Params.issueNumber }}, renderer: [OctommentsRenderer, &amp;#39;#comments&amp;#39;] }).init(); &amp;lt;/script&amp;gt; {{ end }} 配置需要评论的文章 在文章的 metadata 章节加入创建的 issue 的 issue number，如本文的 metadata：</description>
    </item>
    
    <item>
      <title>Rust 对象安全详解</title>
      <link>https://huanglei.rocks/posts/object-safety/</link>
      <pubDate>Thu, 09 Dec 2021 21:57:33 +0800</pubDate>
      
      <guid>https://huanglei.rocks/posts/object-safety/</guid>
      <description>Rust 的 RFC 上只给出了 object-safety 的定义，但是没有解释为何在满足这些条件的时候 trait 是 object safe 的，以及为啥需要 object safety，这反而是初学者最为困惑的点。
为什么需要 object safety？ Rust 通过 trait object 提供了类型擦除、动态分派的能力，但是这个能力是有限制的，不是所有的 trait 都能自动生成实现。 Trait object 本质上是对某个 trait 的自动默认实现，包括一个数据区和一个方法表。Object-safety 就是为了保证 Rust 编译器能够为某个 trait 生成合法自动实现。
 Trait object 的内存布局    Where Self Meets Sized: Revisiting Object Safety
 首先是关于 trait 的 object safety，一个 trait 是对象安全的，当且仅当它满足以下所有条件：
 trait 的类型不能限定为 Self: Sized1️⃣； trait 中所定义的所有方法都是 object-safe 的2️⃣；  接下来是关于方法的 object safety：一个方法是对象安全的，当且仅当这个方法满足下面任意一个特性：
 方法 receiver 的类型限定是 Self: Sized3️⃣ ；或者 满足以下所有条件：  方法不能有泛型参数4️⃣；且 receiver 类型必须是 Self 或者可以解引用为 Self 的引用类型5️⃣ 。目前只包括self/ &amp;amp;self / &amp;amp;mut self/ self: Box&amp;lt;Self&amp;gt;。以后可能也会扩展到 Rc&amp;lt;Self&amp;gt;等等。 Self类型只能用作 receiver 6️⃣     1️⃣ 也就是说，如下的 trait 是不能用作 trait object 的。</description>
    </item>
    
    <item>
      <title>December 2021</title>
      <link>https://huanglei.rocks/gallery/2021/</link>
      <pubDate>Sun, 05 Dec 2021 12:15:59 +0800</pubDate>
      
      <guid>https://huanglei.rocks/gallery/2021/</guid>
      <description> .content img { max-width:100%; }   SONY ILCE-7RM4, Tamron 70-180 f/2.8, 130mm, f/2.8, 1/2000s, ISO 100
    SONY ILCE-7RM4, Sigma 24-70 f/2.8, 45mm, f/3.2, 1/30s, ISO 200
    SONY ILCE-7RM4, Sigma 24-70 f/2.8, 45mm, f/2.8, 1/30sec, ISO 400
  </description>
    </item>
    
    <item>
      <title>Paxos Made Simple 笔记 (WIP)</title>
      <link>https://huanglei.rocks/posts/notes-on-paxos-made-simple/</link>
      <pubDate>Mon, 14 Jun 2021 11:24:18 +0800</pubDate>
      
      <guid>https://huanglei.rocks/posts/notes-on-paxos-made-simple/</guid>
      <description>关于 P2c P2c 是 P2b 的充分不必要条件，why？
  P2b: If a proposal with value v is chosen, then every higher-numbered proposal issued by any proposer has value v. P2c: For any v and n, if a proposal with value v and number n is issued, then there is a set S consisting of a majority of acceptors such that either  (a) no acceptor in S has accepted any proposal numbered less than n, or (b) v is the value of the highest-numbered proposal among all proposals numbered less than n accepted by the acceptors in S.</description>
    </item>
    
    <item>
      <title>Add MathJax and Graphviz support for HUGO</title>
      <link>https://huanglei.rocks/posts/add-math-and-dot-for-hugo/</link>
      <pubDate>Sun, 12 Apr 2020 14:22:22 +0800</pubDate>
      
      <guid>https://huanglei.rocks/posts/add-math-and-dot-for-hugo/</guid>
      <description>Get into your theme folder
  Find some directory named layouts/posts/single.html
  Inside the {{ define main }} block, paste following snippets
  {{ if .Params.viz }} &amp;lt;script type=&amp;#34;text/javascript&amp;#34; src=&amp;#34;https://cdn.bootcss.com/viz.js/1.8.2/viz.js&amp;#34;&amp;gt; &amp;lt;/script&amp;gt; &amp;lt;script type=&amp;#34;text/javascript&amp;#34;&amp;gt; (function(){ var vizPrefix = &amp;#34;language-viz-&amp;#34;; Array.prototype.forEach.call(document.querySelectorAll(&amp;#34;[class^=&amp;#34; + vizPrefix + &amp;#34;]&amp;#34;), function(x){ var engine; x.getAttribute(&amp;#34;class&amp;#34;).split(&amp;#34; &amp;#34;).forEach(function(cls){ if (cls.startsWith(vizPrefix)) { engine = cls.substr(vizPrefix.length); } }); var image = new DOMParser().parseFromString(Viz(x.innerText, {format:&amp;#34;svg&amp;#34;, engine:engine}), &amp;#34;image/svg+xml&amp;#34;); x.parentNode.insertBefore(image.documentElement, x); x.</description>
    </item>
    
    <item>
      <title>About Me</title>
      <link>https://huanglei.rocks/about-me/</link>
      <pubDate>Sun, 12 Apr 2020 11:37:42 +0800</pubDate>
      
      <guid>https://huanglei.rocks/about-me/</guid>
      <description> River Drina, border between Bosnia-Herzegovina and Serbia
 Full-time coder, part-time photographer @HANGZHOU.
 PEK/PVG/SHA/SZX/HGH/NKG NRT SIN SGN CDG/ORY MAD/BCN SVO/LED KBP/ODS BEG REP  </description>
    </item>
    
    <item>
      <title>Graphviz and mathjax demo</title>
      <link>https://huanglei.rocks/posts/math-and-dot-demo/</link>
      <pubDate>Sat, 11 Apr 2020 23:26:41 +0800</pubDate>
      
      <guid>https://huanglei.rocks/posts/math-and-dot-demo/</guid>
      <description>digraph g{ rankdir=LR; node [shape=record,width=01,height=.1]; a[label=&amp;#34;&amp;lt;1&amp;gt;Hash Table|&amp;lt;2&amp;gt;Node|&amp;lt;3&amp;gt;Node|...|&amp;lt;4&amp;gt;TreeNode&amp;#34;]; { // graph[rankdir=LR] node1[label=&amp;#34;{&amp;lt;1&amp;gt;A1|&amp;lt;2&amp;gt;A2|...|An}&amp;#34;] node2[label=&amp;#34;{&amp;lt;1&amp;gt;B1|&amp;lt;2&amp;gt;B2|...|Bn}&amp;#34;] // node3[label=&amp;#34;{&amp;lt;1&amp;gt;C1|&amp;lt;2&amp;gt;C2}&amp;#34;] subgraph cluster_treenode{ penwidth=0; node[shape=circle]; root[label=&amp;#34;&amp;#34;, style=filled,fillcolor=black,width=.2]; n1[label=&amp;#34;&amp;#34;, style=filled,fillcolor=red,width=.2] n2[label=&amp;#34;&amp;#34;, style=filled,fillcolor=black,width=.2] n3[label=&amp;#34;&amp;#34;, style=filled,fillcolor=black,width=.2] n4[label=&amp;#34;&amp;#34;, style=filled,fillcolor=red,width=.2] n5[label=&amp;#34;&amp;#34;, style=filled,fillcolor=black,width=.2] n6[label=&amp;#34;&amp;#34;, style=filled,fillcolor=black,width=.2] root-&amp;gt;n1; n1-&amp;gt;n2; n1-&amp;gt;n3; root-&amp;gt;n4; n4-&amp;gt;n5; n4-&amp;gt;n6; } } a:2:e-&amp;gt;node1:1 [style=dashed]; a:3:e-&amp;gt;node2:1; a:4:e-&amp;gt;root; // node3:d-&amp;gt;node3:sa2; } $$f(a) = \frac{1}{2\pi i} \oint\frac{f(z)}{z-a}dz$$</description>
    </item>
    
  </channel>
</rss>
