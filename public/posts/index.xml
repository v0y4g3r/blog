<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>Posts on Tokamako</title>
		<link>https://huanglei.rocks/posts/</link>
		<description>Recent content in Posts on Tokamako</description>
		<generator>Hugo -- gohugo.io</generator>
		<language>en-us</language>
		<copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
		<lastBuildDate>Thu, 24 Feb 2022 01:18:35 +0800</lastBuildDate>
		<atom:link href="https://huanglei.rocks/posts/index.xml" rel="self" type="application/rss+xml" />
		
		<item>
			<title>Bookkeeper Note</title>
			<link>https://huanglei.rocks/posts/bookkeeper-note/</link>
			<pubDate>Thu, 24 Feb 2022 01:18:35 +0800</pubDate>
			
			<guid>https://huanglei.rocks/posts/bookkeeper-note/</guid>
			<description>BookKeeper 的使用场景  WAL：比如 HDFS Namenode 的 EditLog（要求高可靠） 分布式存储：比如 Pulsar 的消息存储、DistributedLog 等  核心理念  通过条带化写（Data Striping）实现数据的多副本，所有存储节点角色对等； 通过其他的存储组件（ZooKeeper）实现元数据高可靠，故障恢复（recover）流程强依赖 ZK 的元数据；  也可以选用其他的存储服务，要求 1. CP 系统；2. 提供 CAS 原语   基于 RocksDB 提供 (ledger, sequence) -&amp;gt; (file, physicalOffset) 的索引（SingleDirectoryDbLedgerStorage#ledgerIndex）； 同一时刻只有一个 writer 和多个 reader，通过 fencing 机制避免出现多 writer，避免 sequence 乱序； 读写分离，冷热分离（tailing read/catch-up read）提高吞吐；  BookKeeper 的术语  ledger：一写多读的 append-only 文件，ledger 的最小数据单元是 fragment； bookie：存储 ledger 的节点； ledger has many records， called：entry，每个entry都有一个 sequence number，可以根据 ledger + seq 来读取一部分 entry。 quorum：几个 bookie 组成一个 quorum，通过复制提高可用性。 data striping：数据块交织写入到各个设备，提高写入的性能。类似 RAID1 的机制，不过 BookKeeper 的striping 的ensenble 数量是小于 quorum 数量的一种特殊的 striping。   BookKeeper 的 quorum write 机制   Striping 很容易就会导致读取者所看到的 log 不一致，因此 BK 引入了ZK去保存元数据，并且通过 triming 机制（BK称为 reader-initiated ledger recovery）来确保末尾未完整写完整个 quorum 的数据能够被安全删除并且对 reader 不可见。</description>
			<content type="html"><![CDATA[<h1 id="bookkeeper-的使用场景">BookKeeper 的使用场景</h1>
<ul>
<li>WAL：比如 HDFS Namenode 的 EditLog（要求高可靠）</li>
<li>分布式存储：比如 Pulsar 的消息存储、DistributedLog 等</li>
</ul>
<h1 id="核心理念">核心理念</h1>
<ul>
<li>通过条带化写（Data Striping）实现数据的多副本，所有存储节点角色对等；</li>
<li>通过其他的存储组件（ZooKeeper）实现元数据高可靠，故障恢复（recover）流程强依赖 ZK 的元数据；
<ul>
<li>也可以选用其他的存储服务，要求 1. CP 系统；2. 提供 CAS 原语</li>
</ul>
</li>
<li>基于 RocksDB 提供 <code>(ledger, sequence) -&gt; (file, physicalOffset)</code>  的索引（<code>SingleDirectoryDbLedgerStorage#ledgerIndex</code>）；</li>
<li>同一时刻只有一个 writer 和多个 reader，通过 fencing 机制避免出现多 writer，避免 sequence 乱序；</li>
<li>读写分离，冷热分离（tailing read/catch-up read）提高吞吐；</li>
</ul>
<h1 id="bookkeeper-的术语">BookKeeper 的术语</h1>
<ul>
<li>ledger：一写多读的 append-only 文件，ledger 的最小数据单元是 fragment；</li>
<li>bookie：存储 ledger 的节点；</li>
<li>ledger has many records， called：entry，每个entry都有一个 sequence number，可以根据 ledger + seq 来读取一部分 entry。</li>
<li>quorum：几个 bookie 组成一个 quorum，通过复制提高可用性。</li>
<li>data striping：数据块交织写入到各个设备，提高写入的性能。类似 RAID1 的机制，不过 BookKeeper 的striping 的ensenble 数量是小于 quorum 数量的一种特殊的 striping。</li>
</ul>
<p><img src="https://huanglei-rocks-blog.oss-cn-shanghai.aliyuncs.com/blog/20220224230803.png" alt=""></p>
<div style="text-align: center;">
<i>
 BookKeeper 的 quorum write 机制 
</i>
</div>
<p>Striping 很容易就会导致读取者所看到的 log 不一致，因此 BK 引入了ZK去保存元数据，并且通过 triming 机制（BK称为 reader-initiated ledger recovery）来确保末尾未完整写完整个 quorum 的数据能够被安全删除并且对 reader 不可见。</p>
<h1 id="实现细节">实现细节</h1>
<h2 id="bookie">Bookie</h2>
<p>包含两个存储：</p>
<ul>
<li>journal：WAL，同步写</li>
<li>ledger：包含索引，异步写</li>
</ul>
<p><img src="https://huanglei-rocks-blog.oss-cn-shanghai.aliyuncs.com/blog/20220224231150.png" alt=""></p>
<div style="text-align: center;">
<i>
 BookKeeper 的读写路径 
</i>
</div>
<p>理想状况下，journal 和 ledger 应该位于不同的磁盘上，减少他们同时不可用的概率。</p>
<h2 id="bookkeeper-提供的-api">BookKeeper 提供的 API</h2>
<ul>
<li>创建 ledger</li>
<li>向 ledger 新增 entry</li>
<li>打开一个 ledger</li>
<li>从ledger 读取 entry</li>
<li>关闭 ledger 避免后续数据写入</li>
<li>删除一个ledger</li>
</ul>
<h2 id="ledger-创建">Ledger 创建</h2>
<p>一个 ledger 需要由一个 ensemble 来负责，因此创建 ledger 的时候必须指定 ledger 的 quorum 和 ensemble。具备 f+1 个节点的 quorum 可以容忍 f 个节点宕机。</p>
<ul>
<li>quorum：写入节点集合。更大的quorum 提供更强的可用性。</li>
<li>ensemble：striping 所需要的节点总数。更大的 ensemble 提供更大的吞吐。</li>
</ul>
<p><img src="https://huanglei-rocks-blog.oss-cn-shanghai.aliyuncs.com/blog/paper-creating-using-ledger.png?versionId=CAEQIBiBgMDlsZax.RciIGJmZGJjYjRjODNiZjQ4ZDE4OWZkMjVlZWRhNmEzMGJh" alt="paper-creating-using-ledger.png"></p>
<ul>
<li>quorum 是以 round-robin 的形式分散在整个 ensemble 中。</li>
<li>quorum 和 ensemble 这些元数据保存在 zookeeper 中。</li>
</ul>
<blockquote>
<p>这里有个问题，当bk客户端尝试读取 entry 的时候，需要确定从哪些bookie组成的quorum 读取，那这个quorum是怎么确定的？</p>
</blockquote>
<p><img src="https://huanglei-rocks-blog.oss-cn-shanghai.aliyuncs.com/blog/paper-to-read-a-given-entry-e.png?versionId=CAEQIBiBgICTgJmx.RciIGNmMjU4OWFmYTE0YjQ4NzFiNjY0MTM4NzRjZjNjZTJi" alt="image.png"></p>
<h2 id="ledger-关闭">Ledger 关闭</h2>
<p>Ledger 关闭是一个原子的操作，会在 ZK 中记录 ledger 最后一个 entry 的 seq。这里ZK 提供的一致性协议非常重要，否则 Bookkeper 的客户端可能会观察到 ledger 的 不一致。
<img src="https://huanglei-rocks-blog.oss-cn-shanghai.aliyuncs.com/blog/1635067390415-cdc4ede3-9bd7-4bd3-82e7-f3c3091be3d1.png" alt="image.png">
当 BK 的客户端没有 close 一个ledger 就 crash 怎么办？因此需要一个额外的机制来保证所有 open 的ledger 都能够最终被 close。</p>
<h2 id="ledger-的恢复">Ledger 的恢复</h2>
<p>Ledger 的写入者可能在没关闭 ledger 的时候就 crash 了，这种情况下 entry 的元数据尚未更新到 zk中， ledger 的读取者无法安全地确认 ledger中的最后的 entry 是什么，因此 ledger 需要 恢复操作（recovery）。</p>
<p>当 reader 打开一个 ledger 读取的时候，从 ZK 中获取元数据，同时如果发现这个 ledger 尚未被close，就触发一个 recovery 流程。（没 close 就触发吗？？？）</p>
<p>Recovery：确定按所要求的 quorum 写入成功的最后一个 entry，写入到 ZK 中。</p>
<p>如何确认最后一个 entry？
可以简单地从 ledger 一次读取所有的entry，重新写入一遍。
为了加速，reader 向 ensemble 中所有的 bookie 询问 此ledger 写入的最新的 entry 的LAC字段（Last Add Confirmed）。然后恢复流程就可以从最高的 LAC 位置开始，而无需读取整个 ledger。</p>
<p>？？？这里的恢复流程尚不是太清楚。</p>
<h3 id="lac">LAC</h3>
<p>LAC：Last add confirmed，获取一个 quorum 中最后一个被确认写入的 entry 的 id
对于 单个 bookie 而言，所谓的LAC就是当前 ledger 最后一个写入的 entry 的 entry id。而对于客户端而言，获取quorum 的LAC就是获取整个 quorum 中最大的LAC。</p>
<p><strong>这里比较容易混淆：LAC 应该是维护在 writer 本地的，只是每次写入到 bookie 的时候把它放在 entry 的某个字段中。Quorum 中所有 bookie 的最后一个 entry 的 LAC 最大值，所反映的一定是这个 writer 的 LAC 的最大值，这样一来 LAC 的作用就好理解了，相当于是把 writer 的写入确认水位状态随着 entry 写入到了每一个 bookie中。</strong></p>
<blockquote>
<p><strong>这块的介绍可以看 <strong><a href="https://bookkeeper.apache.org/distributedlog/docs/latest/user_guide/design/main.html"><strong>DistributedLog</strong></a></strong>。</strong></p>
</blockquote>
<h1 id="fencing">Fencing</h1>
<p>LAC 只能保证 reader 之间读取的一致性，但是不能避免出现多个 writer。</p>
<p>bookie 检测到某个 ledger 出于 recovery 流程中时，拒绝掉所有这个ledger 写入的请求。</p>
<h3 id="从一个-open-状态的-ledger-读取数据">从一个 open 状态的 ledger 读取数据</h3>
<p>前述都是基于 reader 只能读取 closed 的 ledger 的前提。但是 reader完全有可能需要读取 open 的ledger（废话。。。），因此 BK 提供了绕过了 recovery 流程的读取API。在这个API 中，为了防止 reader 读取到 transient entry（只在 quorum 中复制了一部分，关闭 ledger 后可能会被 trim 掉的 entry），reader会向bookie 查询 ledger 的 LAC，读取 LAC 以前的 entry 是安全的，因为他们都已经被完整地复制了。</p>
<p>Ledger device：第一版不同的 ledger 有不同的文件，后来改为一个（类似RocketMQ的CommitLog），成为entry log。原因是多个文件的随机写入带来的磁盘寻道、Page cache 的竞争大大降低了写入吞吐。不同 ledger 的 entry 都存储在一个 entry log 中。</p>
<p><img src="https://huanglei-rocks-blog.oss-cn-shanghai.aliyuncs.com/blog/1645460567153-66dff109-b35e-4676-b45a-f03706a58eb0.png?versionId=CAEQIBiBgMCI8LGx.RciIGFhYTZkNTNjYWFiOTQzOWU4MzRkYmNjMzRkMWJlMzQz" alt=""></p>
<div style="text-align: center;">
<i>
 Journal to Ledger Log 
</i>
</div>
<p>对于每个ledger，bookie 在 ledger device 上还维护了一个索引，并且把这个索引 映射 到内存，降低索引构建导致的 IO 开销。</p>
<p>Ledger 的设计主要针对写为主的流量。读的场景下，如果命中了内存中的ledger index，那么只需要一次磁盘 IO，否则需要先从 Ledger index文件找到 entry 所在 entry log 中的位置，然后再去 entry log 中读取entry内容。</p>
<h2 id="源码分析">源码分析</h2>
<p><img src="https://huanglei-rocks-blog.oss-cn-shanghai.aliyuncs.com/blog/entry-write-diagram.png" alt="entry-write-diagram.png"></p>
<div style="text-align: center;">
<i>
 Entry 写入的流程 
</i>
</div>
]]></content>
		</item>
		
		<item>
			<title>LSM Tree 笔记</title>
			<link>https://huanglei.rocks/posts/note-on-lsmt/</link>
			<pubDate>Thu, 10 Feb 2022 22:34:39 +0800</pubDate>
			
			<guid>https://huanglei.rocks/posts/note-on-lsmt/</guid>
			<description>写入（Write path）   先从磁盘（HDD）写入的特性引入 append-only 的 WAL。
  对于 KV 结构，如果写入是 append only的，那么就需要合并，不然读取性能太差。
  单文件合并性能差，因此需要按阈值切分为多个小文件，通过归并排序的思路优化合并的效率。
  多路归并要求每个文件有序，为了保证每个文件有序，就需要，数据写入的时候，不直接把 operation 直接写入到磁盘，而是先在内存缓存一段时间，并且在内存排好序，然后再一次把整个文件 flush 到磁盘。
 内存有序的数据结构：跳表、红黑树、B+ 树 buffer 在内存的数据丢了怎么办？先写 redo log    有序数据结构  RocksDB 的数据结构比较：选择跳表的原因是跳表支持并发插入。
 LSMT 的数据分类
 内存数据：MemTable 磁盘数据：SSTable（Sorted Sequence Table） 日志：redo log  内存数据组织 内存的数据需要保证有序，同时支持高性能的插入和查找。
 ART：自适应基树（比如 Bitcask 采用）； SkipList：LevelDB、RocksDB 等。  SSTable 文件格式 按 Block 进行存储，可以参考 LevelDB 和 RocksDB 的 SST 文件的格式。</description>
			<content type="html"><![CDATA[<h2 id="写入write-path">写入（Write path）</h2>
<ul>
<li>
<p>先从磁盘（HDD）写入的特性引入 append-only 的 WAL。</p>
</li>
<li>
<p>对于 KV 结构，如果写入是 append only的，那么就需要合并，不然读取性能太差。</p>
</li>
<li>
<p>单文件合并性能差，因此需要按阈值切分为多个小文件，通过归并排序的思路优化合并的效率。</p>
</li>
<li>
<p>多路归并要求每个文件有序，为了保证每个文件有序，就需要，数据写入的时候，不直接把 operation 直接写入到磁盘，而是先在内存缓存一段时间，并且在内存排好序，然后再一次把整个文件 flush 到磁盘。</p>
<ul>
<li>内存有序的数据结构：跳表、红黑树、B+ 树</li>
<li>buffer 在内存的数据丢了怎么办？先写 redo log</li>
</ul>
</li>
</ul>
<h2 id="有序数据结构">有序数据结构</h2>
<p><img src="https://gw.alipayobjects.com/zos/antfincdn/V8oKiYS5z/1639280343.png" alt=""></p>
<blockquote>
<p><a href="https://github.com/facebook/rocksdb/wiki/MemTable">RocksDB 的数据结构比较</a>：选择跳表的原因是跳表支持并发插入。</p>
</blockquote>
<p>LSMT 的数据分类</p>
<ul>
<li>内存数据：MemTable</li>
<li>磁盘数据：SSTable（Sorted Sequence Table）</li>
<li>日志：redo log</li>
</ul>
<h2 id="内存数据组织">内存数据组织</h2>
<p>内存的数据需要保证有序，同时支持高性能的插入和查找。</p>
<ul>
<li>ART：自适应基树（比如 Bitcask 采用）；</li>
<li>SkipList：LevelDB、RocksDB 等。</li>
</ul>
<h2 id="sstable-文件格式">SSTable 文件格式</h2>
<p>按 Block 进行存储，可以参考 LevelDB 和 RocksDB 的 SST 文件的格式。</p>
<h2 id="合并策略">合并策略</h2>
<ul>
<li>
<p>分级合并（Leveling Merge Policy）</p>
<ul>
<li>每一级都有且只有一个文件</li>
</ul>
</li>
<li>
<p>分层合并 (Tiering Merge Policy)</p>
<ul>
<li>每一级有多个小文件，每个小文件中的 key 不重叠（LevelDB 和 RocksDB采用，尽管他们称自己为 leveling merge）</li>
</ul>
</li>
<li>
<p>合并时间：定时合并、达到阈值合并。</p>
</li>
</ul>
<h2 id="读取read-path">读取（Read path）</h2>
<p>核心原则：先热后冷读取最新的数据，一旦读取到就停止。</p>
<ul>
<li>优先读取 MemTable，然后读取 SSTable</li>
</ul>
<h3 id="读取的优化">读取的优化</h3>
<ul>
<li>通过 BloomFilter 优化不存在的数据的判断</li>
<li>SSTable 分区</li>
<li>压缩</li>
</ul>
<h2 id="lsmt-的问题">LSMT 的问题</h2>
<h3 id="读放大">读放大</h3>
<p>一次 key 的读取需要由新到旧依次读取，涉及到不止一次IO，在范围查询的时候尤其明显。</p>
<h3 id="写放大">写放大</h3>
<p>后台合并（compaction）导致一个文件可能需要被写入多次。</p>
<h3 id="空间放大">空间放大</h3>
<p>Append-only 导致过期数据一致存在，直到被清理</p>
<h2 id="总结">总结</h2>
<ul>
<li>写放大：尽管 LSM Tree 通过顺序 IO 提供了更大的写入吞吐，但是写入放大的问题会争抢正常写入的磁盘带宽，从而降低性能和磁盘的使用寿命。</li>
<li>合并：后台的合并操作导致 write stall</li>
<li>新硬件：Remote compaction，Compaction offloading，AEP</li>
</ul>
<p>索引存储</p>
<ul>
<li>索引不存储
<ul>
<li>buntdb：每次重启重建</li>
</ul>
</li>
<li>索引存储
<ul>
<li>分离存储
<ul>
<li>Bitcask</li>
<li>MySQL MyISAM</li>
</ul>
</li>
<li>一起存储
<ul>
<li>BoltDB</li>
<li>MySQL Innodb</li>
<li>LevelDB (SStable)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="reference">Reference</h1>
<ul>
<li><a href="https://www.youtube.com/watch?v=adamqSuHHck&amp;ab_channel=TalkGo">理论结合实践详解 lsm 树存储引擎（bitcask、moss、leveldb 等）</a></li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>使用 GitHub Issue 作为 Hugo 的评论系统</title>
			<link>https://huanglei.rocks/posts/hugo-comment-with-github-issues/</link>
			<pubDate>Thu, 10 Feb 2022 15:07:10 +0800</pubDate>
			
			<guid>https://huanglei.rocks/posts/hugo-comment-with-github-issues/</guid>
			<description>安装 Octomments 按照 Octomments 的介绍，将 Octomments 安装到您的 GitHub 账户，确保它拥有访问您的目标 repo 的 issue 的权限。
配置 GitHub issue 在配置文件中增加配置项：
 comment.owner：Issue repo 的拥有者 comment.repo：Issue repo 的名字  配置 Comment 组件 在您的博客站点根目录下的layouts/partials/comments.html 模板中增加：
{{ if .Params.issueNumber -}} &amp;lt;link href=&amp;#34;https://unpkg.com/octomments/build/ocs-ui.min.css&amp;#34; rel=&amp;#34;stylesheet&amp;#34;&amp;gt; &amp;lt;div id=&amp;#34;comments&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;script src=&amp;#34;https://unpkg.com/octomments/build/ocs.min.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;script&amp;gt; Octomments({ github: { owner: &amp;#39;{{ $.Site.Params.comment.owner }}&amp;#39;, repo: &amp;#39;{{ $.Site.Params.comment.repo }}&amp;#39;, }, issueNumber: {{ .Params.issueNumber }}, renderer: [OctommentsRenderer, &amp;#39;#comments&amp;#39;] }).init(); &amp;lt;/script&amp;gt; {{ end }} 配置需要评论的文章 在文章的 metadata 章节加入创建的 issue 的 issue number，如本文的 metadata：</description>
			<content type="html"><![CDATA[<h1 id="安装-octomments">安装 Octomments</h1>
<p>按照 <a href="https://ocs.vercel.app/">Octomments</a> 的介绍，将 Octomments 安装到您的 GitHub 账户，确保它拥有访问您的目标 repo 的 issue 的权限。</p>
<h1 id="配置-github-issue">配置 GitHub issue</h1>
<p>在配置文件中增加配置项：</p>
<ul>
<li><code>comment.owner</code>：Issue repo 的拥有者</li>
<li><code>comment.repo</code>：Issue repo 的名字</li>
</ul>
<h1 id="配置-comment-组件">配置 Comment 组件</h1>
<p>在您的博客站点根目录下的<code>layouts/partials/comments.html</code> 模板中增加：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-html" data-lang="html">{{ if .Params.issueNumber -}}
<span class="p">&lt;</span><span class="nt">link</span> <span class="na">href</span><span class="o">=</span><span class="s">&#34;https://unpkg.com/octomments/build/ocs-ui.min.css&#34;</span> <span class="na">rel</span><span class="o">=</span><span class="s">&#34;stylesheet&#34;</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="nt">div</span> <span class="na">id</span><span class="o">=</span><span class="s">&#34;comments&#34;</span><span class="p">&gt;&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="nt">script</span> <span class="na">src</span><span class="o">=</span><span class="s">&#34;https://unpkg.com/octomments/build/ocs.min.js&#34;</span><span class="p">&gt;&lt;/</span><span class="nt">script</span><span class="p">&gt;</span>

<span class="p">&lt;</span><span class="nt">script</span><span class="p">&gt;</span>
  <span class="nx">Octomments</span><span class="p">({</span>
    <span class="nx">github</span><span class="o">:</span> <span class="p">{</span>
      <span class="nx">owner</span><span class="o">:</span> <span class="s1">&#39;{{ $.Site.Params.comment.owner }}&#39;</span><span class="p">,</span>
      <span class="nx">repo</span><span class="o">:</span> <span class="s1">&#39;{{ $.Site.Params.comment.repo }}&#39;</span><span class="p">,</span>
    <span class="p">},</span>
    <span class="nx">issueNumber</span><span class="o">:</span> <span class="p">{{</span> <span class="p">.</span><span class="nx">Params</span><span class="p">.</span><span class="nx">issueNumber</span> <span class="p">}},</span>
    <span class="nx">renderer</span><span class="o">:</span> <span class="p">[</span><span class="nx">OctommentsRenderer</span><span class="p">,</span> <span class="s1">&#39;#comments&#39;</span><span class="p">]</span>
  <span class="p">}).</span><span class="nx">init</span><span class="p">();</span>
<span class="p">&lt;/</span><span class="nt">script</span><span class="p">&gt;</span>

{{ end }}
</code></pre></div><h1 id="配置需要评论的文章">配置需要评论的文章</h1>
<p>在文章的 metadata 章节加入创建的 issue 的 issue number，如本文的 metadata：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="nn">---</span><span class="w">
</span><span class="w"></span><span class="nt">title</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;使用 GitHub Issue 作为 Hugo 的评论系统&#34;</span><span class="w">
</span><span class="w"></span><span class="nt">date</span><span class="p">:</span><span class="w"> </span><span class="ld">2022-02-10T15:07:10</span><span class="m">+08</span><span class="p">:</span><span class="m">00</span><span class="w">
</span><span class="w"></span><span class="nt">draft</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="w">
</span><span class="w"></span><span class="nt">toc</span><span class="p">:</span><span class="w"> </span><span class="kc">false</span><span class="w">
</span><span class="w"></span><span class="nt">issueNumber</span><span class="p">:</span><span class="w"> </span><span class="m">3</span><span class="w">
</span><span class="w"></span><span class="nt">images</span><span class="p">:</span><span class="w">
</span><span class="w"></span><span class="nt">tags</span><span class="p">:</span><span class="w"> 
</span><span class="w">  </span>- <span class="l">Hugo</span><span class="w">
</span><span class="w">  </span>- <span class="l">Github</span><span class="w">
</span><span class="w"></span><span class="nn">---</span><span class="w">
</span></code></pre></div><p>这样本文的末尾就会出现一个评论栏啦，所有对本文的评论都会同步到 GitHub 的 issue 中。</p>
]]></content>
		</item>
		
		<item>
			<title>Rust 对象安全详解</title>
			<link>https://huanglei.rocks/posts/object-safety/</link>
			<pubDate>Thu, 09 Dec 2021 21:57:33 +0800</pubDate>
			
			<guid>https://huanglei.rocks/posts/object-safety/</guid>
			<description>Rust 的 RFC 上只给出了 object-safety 的定义，但是没有解释为何在满足这些条件的时候 trait 是 object safe 的，以及为啥需要 object safety，这反而是初学者最为困惑的点。
为什么需要 object safety？ Rust 通过 trait object 提供了类型擦除、动态分派的能力，但是这个能力是有限制的，不是所有的 trait 都能自动生成实现。 Trait object 本质上是对某个 trait 的自动默认实现，包括一个数据区和一个方法表。Object-safety 就是为了保证 Rust 编译器能够为某个 trait 生成合法自动实现。
 Trait object 的内存布局    Where Self Meets Sized: Revisiting Object Safety
 首先是关于 trait 的 object safety，一个 trait 是对象安全的，当且仅当它满足以下所有条件：
 trait 的类型不能限定为 Self: Sized1️⃣； trait 中所定义的所有方法都是 object-safe 的2️⃣；  接下来是关于方法的 object safety：一个方法是对象安全的，当且仅当这个方法满足下面任意一个特性：
 方法 receiver 的类型限定是 Self: Sized3️⃣ ；或者 满足以下所有条件：  方法不能有泛型参数4️⃣；且 receiver 类型必须是 Self 或者可以解引用为 Self 的引用类型5️⃣ 。目前只包括self/ &amp;amp;self / &amp;amp;mut self/ self: Box&amp;lt;Self&amp;gt;。以后可能也会扩展到 Rc&amp;lt;Self&amp;gt;等等。 Self类型只能用作 receiver 6️⃣     1️⃣ 也就是说，如下的 trait 是不能用作 trait object 的。</description>
			<content type="html"><![CDATA[<p>Rust 的 <a href="https://rust-lang.github.io/rfcs/0255-object-safety.html">RFC</a> 上只给出了 object-safety 的定义，但是没有解释为何在满足这些条件的时候 trait 是 object safe 的，以及为啥需要 object safety，这反而是初学者最为困惑的点。</p>
<h1 id="为什么需要-object-safety">为什么需要 object safety？</h1>
<p>Rust 通过 trait object 提供了类型擦除、动态分派的能力，但是这个能力是有限制的，不是所有的 trait 都能自动生成实现。
<strong>Trait object 本质上是对某个 trait 的自动默认实现，包括一个数据区和一个方法表。<u>Object-safety 就是为了保证 Rust 编译器能够为某个 trait 生成合法自动实现。</u></strong></p>
<p><img src="https://gw.alipayobjects.com/zos/antfincdn/QAgzwRCoT/1644416416.png" alt="trait-object.png"></p>
<div style="text-align: center;">
<i>
 Trait object 的内存布局 
</i>
</div>
<blockquote>
<p><a href="https://huonw.github.io/blog/2015/05/where-self-meets-sized-revisiting-object-safety/">Where Self Meets Sized: Revisiting Object Safety</a></p>
</blockquote>
<p>首先是关于 trait 的 object safety，一个 trait 是对象安全的，当且仅当它<strong>满足以下<u>所有</u>条件</strong>：</p>
<ul>
<li>trait 的类型不能限定为 <code>Self: Sized</code><sup>1️⃣</sup>；</li>
<li>trait 中所定义的所有方法都是 object-safe 的<sup>2️⃣</sup>；</li>
</ul>
<p>接下来是关于方法的 object safety：一个方法是对象安全的，当且仅当这个方法<strong>满足下面<u>任意一个</u>特性</strong>：</p>
<ul>
<li>方法 receiver 的类型限定是 <code>Self: Sized</code><sup>3️⃣ </sup>；或者</li>
<li>满足以下所有条件：
<ul>
<li>方法不能有泛型参数<sup>4️⃣</sup>；且</li>
<li>receiver 类型必须是 Self 或者可以解引用为 Self 的引用类型<sup>5️⃣ </sup>。目前只包括<code>self</code>/ <code>&amp;self</code> / <code>&amp;mut self</code>/ <code>self: Box&lt;Self&gt;</code>。以后可能也会扩展到 <code>Rc&lt;Self&gt;</code>等等。</li>
<li><code>Self</code>类型只能用作 receiver <sup>6️⃣ </sup></li>
</ul>
</li>
</ul>
<p>1️⃣   也就是说，如下的 trait 是不能用作 trait object 的。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="n">Test</span>: <span class="nb">Sized</span> <span class="p">{</span><span class="w">
</span><span class="w">	</span><span class="k">fn</span> <span class="nf">some_method</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>为什么trait 的方法的 receiver 不能限定为 <code>Self: Sized</code>？因为 trait object 本身是动态分派的，编译期无法确定 trait object 的大小。如果这个时候 trait object 的方法又要求 Self 大小可确定，那就互相矛盾了。
需要注意的是，trait object 自身的大小是可确定的，因为其只包括指向数据的指针和指向 vtable 的指针而已。</p>
<p>2️⃣   要求 trait 所有的方法都是对象安全的也是为了确保动态分派的时候能够正确从 vtable 中找到方法进行调用。</p>
<p>3️⃣   由于 trait object 自身是 Unsized，如果方法限定了<code>Self: Sized</code>，那么一定无法通过 trait object 去调用。也就不会导致动态分派的 object safety 问题，因此一个限定了 <code>Self: Sized</code>的 trait 方法也被认为是 object-safe 的。</p>
<blockquote>
<ul>
<li><a href="https://stackoverflow.com/questions/42620022/why-does-a-generic-method-inside-a-trait-require-trait-object-to-be-sized">Why does a generic method inside a trait require trait object to be sized? - Stack Overflow</a></li>
<li><a href="https://github.com/rust-lang/rust/issues/22031">A method marked where Self: Sized on a trait should not be considered during object safety checks #22031</a></li>
</ul>
</blockquote>
<p>4️⃣   如果方法不限定 <code>Self: Sized</code> ，就意味着那么这个方法首先不能有泛型参数。如果有泛型参数，那么 vtable 中的方法列表大小是难以确定的。当然如果非要做，在编译期，rust 编译器可以拿到 trait 的所有具体实现，然后为每一个具体实现在 vtable 生成一个特化的方法项。但是首先这会大大降低编译速度，其次也会引入极大的复杂性。因此 Rust 的 trait object 直接禁止了这种使用场景。</p>
<blockquote>
<p><a href="https://stackoverflow.com/questions/67767207/why-are-trait-methods-with-generic-type-parameters-object-unsafe">Why are trait methods with generic type parameters object-unsafe?</a></p>
</blockquote>
<p>5️⃣   如果方法没有 receiver，那么使用 trait object 毫无意义，因为这个方法的调用根本不需要 trait object 里面的 data 指针。</p>
<p>6️⃣   假设 trait 定义了这么一个方法：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="n">Test</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">	</span><span class="k">fn</span> <span class="nf">duplicate</span><span class="p">(</span><span class="bp">self</span>: <span class="nc">Self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>那么这个 trait 的 duplicate 方法要求返回的类型和方法 receiver 的类型是一样的。如果 Trait 是静态分派，那么在编译器就可以确定所有可能的方法签名。比如结构体 A、B 实现了 Test trait，那么 duplicate 方法所有可能的签名是：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">duplicate</span><span class="p">(</span><span class="bp">self</span>: <span class="nc">A</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">A</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">duplicate</span><span class="p">(</span><span class="bp">self</span>: <span class="nc">B</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">B</span><span class="p">;</span><span class="w">
</span></code></pre></div><p>而在动态分派下，从一个 trait object 发起方法的调用，也就无法在编译期约束不同位置的 Self 类型都是一致的，完全有可能出现下面的情况：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">duplicate</span><span class="p">(</span><span class="bp">self</span>: <span class="nc">B</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">A</span><span class="p">;</span><span class="w">
</span></code></pre></div><p>显然这不是对 <code>Test</code> 这个 trait 的一个合法实现。</p>
<ul>
<li><a href="https://rust-lang.github.io/rfcs/0255-object-safety.html">https://rust-lang.github.io/rfcs/0255-object-safety.html</a></li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>Paxos Made Simple 笔记 (WIP)</title>
			<link>https://huanglei.rocks/posts/notes-on-paxos-made-simple/</link>
			<pubDate>Mon, 14 Jun 2021 11:24:18 +0800</pubDate>
			
			<guid>https://huanglei.rocks/posts/notes-on-paxos-made-simple/</guid>
			<description>关于 P2c P2c 是 P2b 的充分不必要条件，why？
  P2b: If a proposal with value v is chosen, then every higher-numbered proposal issued by any proposer has value v. P2c: For any v and n, if a proposal with value v and number n is issued, then there is a set S consisting of a majority of acceptors such that either  (a) no acceptor in S has accepted any proposal numbered less than n, or (b) v is the value of the highest-numbered proposal among all proposals numbered less than n accepted by the acceptors in S.</description>
			<content type="html"><![CDATA[<h1 id="关于-p2c">关于 P2c</h1>
<p>P2c 是 P2b 的充分不必要条件，why？</p>
<blockquote>
<ul>
<li>P2b: If a proposal with value v is chosen, then every higher-numbered proposal issued by any proposer has value <code>v</code>.</li>
<li>P2c: For any <code>v</code> and <code>n</code>, if a proposal with value <code>v</code> and number <code>n</code> is issued, then there is a set S consisting of a majority of acceptors such that either
<ul>
<li>(a) no acceptor in S has accepted any proposal numbered less than <code>n</code>, or</li>
<li>(b) <code>v</code> is the value of the highest-numbered proposal among all proposals numbered less than <code>n</code> accepted by the acceptors in S.</li>
</ul>
</li>
</ul>
</blockquote>
<p>已知 proposal:<code>(m,v)</code>被选中，要满足任意 proposer 提出序号 n （n &gt; m）的 proposal 的值都是 <code>v</code>，那么只要满足条件：<u> $ \forall i\in [m,\ n-1]$ ，有 proposal <code>i</code> 的值是 <code>v</code> 1</u>，那么根据数学归纳法，proposal <code>n</code>的值也必然是 <code>v</code>。</p>
<p>1: 是附加假设，我们需要根据这个附加假设去约束 proposer 的行为，从而使得 P2b 能够被满足。下面就需要解释这个附加假设对 proposer 的行为做出了什么样的约束。</p>
<p>由于 <code>(m,v)</code>已经被选中了，那就意味着存在一个 acceptor 的集合 C 满足任意 C 中的 acceptor 都 accept 了<code>(m,v)</code>，再加上我们需要让附加假设（满足 $i\in [m,\ n-1]$ ，有 proposal <code>i</code> 的值是 <code>v</code>）成立，
这就意味着所谓的 C-condition 2 ，对于 accept 了 <code>(m,v)</code> 的 acceptor 集合 C，满足：</p>
<ul>
<li>(1)  C 中的所有 acceptor 都 accept 了 $[m,\ n-1]$ 中的一个 proposal（因为至少有<code>m</code>已经被 C 中的所有 acceptor 给 accept 了）</li>
<li>(2) $[m,\ n-1]$ 中所有的被任意 acceptor 所 accept 的 proposal 的值都是 <code>v</code>（注意，这里约束的对象从 proposer 变成了 acceptor，实际上 narrow down 了，因为是非拜占庭问题，所有被 acceptor 所 accept 的值都需要 proposer 提出）。</li>
</ul>
<p>那么只要 proposer 满足 P2c，就能满足所谓的 C-condition，从而实现 P2c -&gt; C-condidtion -&gt; 附加假设 1-&gt; P2b 的证明路径。</p>
<blockquote>
<p>为什么 P2c 可以保证 C-condidition？
P2c 约束了 proposer 每次提案之前先要知道 majority 的情况，由于<code>(m,v)</code>已经 chosen，因此符合 P2c 的 proposer 在提出 m+1 的时候，提案的值必然是 m（highest accepted proposal）的值 v，m+2、m+3 直到 n-1 都是这样，从而可以保证 C-condition 的 (2)，</p>
</blockquote>
<p>因此 P2b 到 P2c 实际上是让约束逐步可实现化的 narrow down，因为让 proposer 去感知 acceptor 的状态是更容易实现的。</p>
<blockquote>
<p>Learning about proposals already accepted is easy enough; predicting future acceptances is hard. Instead of trying to predict the future, the proposer controls it by extracting a promise that there won’t be any such acceptances.</p>
</blockquote>
]]></content>
		</item>
		
		<item>
			<title>Add MathJax and Graphviz support for HUGO</title>
			<link>https://huanglei.rocks/posts/add-math-and-dot-for-hugo/</link>
			<pubDate>Sun, 12 Apr 2020 14:22:22 +0800</pubDate>
			
			<guid>https://huanglei.rocks/posts/add-math-and-dot-for-hugo/</guid>
			<description>Get into your theme folder
  Find some directory named layouts/posts/single.html
  Inside the {{ define main }} block, paste following snippets
  {{ if .Params.viz }} &amp;lt;script type=&amp;#34;text/javascript&amp;#34; src=&amp;#34;https://cdn.bootcss.com/viz.js/1.8.2/viz.js&amp;#34;&amp;gt; &amp;lt;/script&amp;gt; &amp;lt;script type=&amp;#34;text/javascript&amp;#34;&amp;gt; (function(){ var vizPrefix = &amp;#34;language-viz-&amp;#34;; Array.prototype.forEach.call(document.querySelectorAll(&amp;#34;[class^=&amp;#34; + vizPrefix + &amp;#34;]&amp;#34;), function(x){ var engine; x.getAttribute(&amp;#34;class&amp;#34;).split(&amp;#34; &amp;#34;).forEach(function(cls){ if (cls.startsWith(vizPrefix)) { engine = cls.substr(vizPrefix.length); } }); var image = new DOMParser().parseFromString(Viz(x.innerText, {format:&amp;#34;svg&amp;#34;, engine:engine}), &amp;#34;image/svg+xml&amp;#34;); x.parentNode.insertBefore(image.documentElement, x); x.</description>
			<content type="html"><![CDATA[<ol>
<li>
<p>Get into your theme folder</p>
</li>
<li>
<p>Find some directory named <code>layouts/posts/single.html</code></p>
</li>
<li>
<p>Inside the <code>{{ define main }}</code> block, paste following snippets</p>
</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="p">{{</span> <span class="k">if</span> <span class="p">.</span><span class="nx">Params</span><span class="p">.</span><span class="nx">viz</span> <span class="p">}}</span>
  <span class="o">&lt;</span><span class="nx">script</span> <span class="nx">type</span><span class="o">=</span><span class="s2">&#34;text/javascript&#34;</span> <span class="nx">src</span><span class="o">=</span><span class="s2">&#34;https://cdn.bootcss.com/viz.js/1.8.2/viz.js&#34;</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="err">/script&gt;</span>
  <span class="o">&lt;</span><span class="nx">script</span> <span class="nx">type</span><span class="o">=</span><span class="s2">&#34;text/javascript&#34;</span><span class="o">&gt;</span>
  <span class="p">(</span><span class="kd">function</span><span class="p">(){</span>
    <span class="kd">var</span> <span class="nx">vizPrefix</span> <span class="o">=</span> <span class="s2">&#34;language-viz-&#34;</span><span class="p">;</span>
    <span class="nb">Array</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">forEach</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nb">document</span><span class="p">.</span><span class="nx">querySelectorAll</span><span class="p">(</span><span class="s2">&#34;[class^=&#34;</span> <span class="o">+</span> <span class="nx">vizPrefix</span> <span class="o">+</span> <span class="s2">&#34;]&#34;</span><span class="p">),</span> <span class="kd">function</span><span class="p">(</span><span class="nx">x</span><span class="p">){</span>
      <span class="kd">var</span> <span class="nx">engine</span><span class="p">;</span>
      <span class="nx">x</span><span class="p">.</span><span class="nx">getAttribute</span><span class="p">(</span><span class="s2">&#34;class&#34;</span><span class="p">).</span><span class="nx">split</span><span class="p">(</span><span class="s2">&#34; &#34;</span><span class="p">).</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">cls</span><span class="p">){</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">cls</span><span class="p">.</span><span class="nx">startsWith</span><span class="p">(</span><span class="nx">vizPrefix</span><span class="p">))</span> <span class="p">{</span>
          <span class="nx">engine</span> <span class="o">=</span> <span class="nx">cls</span><span class="p">.</span><span class="nx">substr</span><span class="p">(</span><span class="nx">vizPrefix</span><span class="p">.</span><span class="nx">length</span><span class="p">);</span>
        <span class="p">}</span>
      <span class="p">});</span>
      <span class="kd">var</span> <span class="nx">image</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">DOMParser</span><span class="p">().</span><span class="nx">parseFromString</span><span class="p">(</span><span class="nx">Viz</span><span class="p">(</span><span class="nx">x</span><span class="p">.</span><span class="nx">innerText</span><span class="p">,</span> <span class="p">{</span><span class="nx">format</span><span class="o">:</span><span class="s2">&#34;svg&#34;</span><span class="p">,</span> <span class="nx">engine</span><span class="o">:</span><span class="nx">engine</span><span class="p">}),</span> <span class="s2">&#34;image/svg+xml&#34;</span><span class="p">);</span>
      <span class="nx">x</span><span class="p">.</span><span class="nx">parentNode</span><span class="p">.</span><span class="nx">insertBefore</span><span class="p">(</span><span class="nx">image</span><span class="p">.</span><span class="nx">documentElement</span><span class="p">,</span> <span class="nx">x</span><span class="p">);</span>
      <span class="nx">x</span><span class="p">.</span><span class="nx">style</span><span class="p">.</span><span class="nx">display</span> <span class="o">=</span> <span class="s1">&#39;none&#39;</span>
      <span class="nx">x</span><span class="p">.</span><span class="nx">parentNode</span><span class="p">.</span><span class="nx">style</span><span class="p">.</span><span class="nx">backgroundColor</span> <span class="o">=</span> <span class="s2">&#34;white&#34;</span>
    <span class="p">});</span>
  <span class="p">})();</span>
  <span class="o">&lt;</span><span class="err">/script&gt;</span>
<span class="p">{{</span> <span class="nx">end</span> <span class="p">}}</span>

<span class="p">{{</span> <span class="k">if</span>  <span class="p">.</span><span class="nx">Params</span><span class="p">.</span><span class="nx">math</span>   <span class="p">}}</span>
  <span class="o">&lt;</span><span class="nx">script</span> <span class="nx">type</span><span class="o">=</span><span class="s2">&#34;text/javascript&#34;</span><span class="o">&gt;</span>
    <span class="nb">window</span><span class="p">.</span><span class="nx">MathJax</span> <span class="o">=</span> <span class="p">{</span>
      <span class="nx">tex2jax</span><span class="o">:</span> <span class="p">{</span>
        <span class="nx">inlineMath</span><span class="o">:</span> <span class="p">[[</span><span class="s1">&#39;$&#39;</span><span class="p">,</span><span class="s1">&#39;$&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;\\(&#39;</span><span class="p">,</span><span class="s1">&#39;\\)&#39;</span><span class="p">]],</span>
        <span class="nx">displayMath</span><span class="o">:</span> <span class="p">[[</span><span class="s1">&#39;$$&#39;</span><span class="p">,</span><span class="s1">&#39;$$&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;\[&#39;</span><span class="p">,</span><span class="s1">&#39;\]&#39;</span><span class="p">]],</span>
        <span class="nx">processEscapes</span><span class="o">:</span> <span class="kc">true</span><span class="p">,</span>
        <span class="nx">processEnvironments</span><span class="o">:</span> <span class="kc">true</span><span class="p">,</span>
        <span class="nx">skipTags</span><span class="o">:</span> <span class="p">[</span><span class="s1">&#39;script&#39;</span><span class="p">,</span> <span class="s1">&#39;noscript&#39;</span><span class="p">,</span> <span class="s1">&#39;style&#39;</span><span class="p">,</span> <span class="s1">&#39;textarea&#39;</span><span class="p">,</span> <span class="s1">&#39;pre&#39;</span><span class="p">],</span>
        <span class="nx">TeX</span><span class="o">:</span> <span class="p">{</span> <span class="nx">equationNumbers</span><span class="o">:</span> <span class="p">{</span> <span class="nx">autoNumber</span><span class="o">:</span> <span class="s2">&#34;AMS&#34;</span> <span class="p">},</span>
          <span class="nx">extensions</span><span class="o">:</span> <span class="p">[</span><span class="s2">&#34;AMSmath.js&#34;</span><span class="p">,</span> <span class="s2">&#34;AMSsymbols.js&#34;</span><span class="p">,</span> <span class="s2">&#34;color.js&#34;</span><span class="p">]</span> <span class="p">}</span>
      <span class="p">},</span>
      <span class="nx">AuthorInit</span><span class="o">:</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
        <span class="nx">MathJax</span><span class="p">.</span><span class="nx">Hub</span><span class="p">.</span><span class="nx">Register</span><span class="p">.</span><span class="nx">StartupHook</span><span class="p">(</span><span class="s2">&#34;Begin&#34;</span><span class="p">,</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
          <span class="nx">MathJax</span><span class="p">.</span><span class="nx">Hub</span><span class="p">.</span><span class="nx">Queue</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
            <span class="kd">var</span> <span class="nx">all</span> <span class="o">=</span> <span class="nx">MathJax</span><span class="p">.</span><span class="nx">Hub</span><span class="p">.</span><span class="nx">getAllJax</span><span class="p">(),</span> <span class="nx">i</span><span class="p">;</span>
            <span class="k">for</span><span class="p">(</span><span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">all</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
              <span class="nx">all</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">SourceElement</span><span class="p">().</span><span class="nx">parentNode</span><span class="p">.</span><span class="nx">className</span> <span class="o">+=</span> <span class="s1">&#39; has-jax&#39;</span><span class="p">;</span>
            <span class="p">}</span>
          <span class="p">})</span>
        <span class="p">});</span>
      <span class="p">}</span>
    <span class="p">};</span>
  <span class="o">&lt;</span><span class="err">/script&gt;</span>
  <span class="o">&lt;</span><span class="nx">script</span>  <span class="nx">type</span><span class="o">=</span><span class="s2">&#34;text/javascript&#34;</span>
    <span class="nx">src</span><span class="o">=</span><span class="s2">&#34;https://cdn.bootcss.com/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML&#34;</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="err">/script&gt;</span>
<span class="p">{{</span> <span class="nx">end</span> <span class="p">}}</span>
</code></pre></div><ol start="4">
<li>Create some posts and add following config inside front-matter</li>
</ol>
<pre tabindex="0"><code>viz: true
math: true
</code></pre><p>And try some graphviz and mathjax stuff!</p>
<p><img src="/images/mathjax-dot-demo.png" alt="mathjax-dot-demo"></p>
<blockquote>
<p>You may check the demo <a href="/posts/math-and-dot-demo">here</a></p>
</blockquote>
]]></content>
		</item>
		
		<item>
			<title>Graphviz and mathjax demo</title>
			<link>https://huanglei.rocks/posts/math-and-dot-demo/</link>
			<pubDate>Sat, 11 Apr 2020 23:26:41 +0800</pubDate>
			
			<guid>https://huanglei.rocks/posts/math-and-dot-demo/</guid>
			<description>digraph g{ rankdir=LR; node [shape=record,width=01,height=.1]; a[label=&amp;quot;&amp;lt;1&amp;gt;Hash Table|&amp;lt;2&amp;gt;Node|&amp;lt;3&amp;gt;Node|...|&amp;lt;4&amp;gt;TreeNode&amp;quot;]; { // graph[rankdir=LR] node1[label=&amp;quot;{&amp;lt;1&amp;gt;A1|&amp;lt;2&amp;gt;A2|...|An}&amp;quot;] node2[label=&amp;quot;{&amp;lt;1&amp;gt;B1|&amp;lt;2&amp;gt;B2|...|Bn}&amp;quot;] // node3[label=&amp;quot;{&amp;lt;1&amp;gt;C1|&amp;lt;2&amp;gt;C2}&amp;quot;] subgraph cluster_treenode{ penwidth=0; node[shape=circle]; root[label=&amp;quot;&amp;quot;, style=filled,fillcolor=black,width=.2]; n1[label=&amp;quot;&amp;quot;, style=filled,fillcolor=red,width=.2] n2[label=&amp;quot;&amp;quot;, style=filled,fillcolor=black,width=.2] n3[label=&amp;quot;&amp;quot;, style=filled,fillcolor=black,width=.2] n4[label=&amp;quot;&amp;quot;, style=filled,fillcolor=red,width=.2] n5[label=&amp;quot;&amp;quot;, style=filled,fillcolor=black,width=.2] n6[label=&amp;quot;&amp;quot;, style=filled,fillcolor=black,width=.2] root-&amp;gt;n1; n1-&amp;gt;n2; n1-&amp;gt;n3; root-&amp;gt;n4; n4-&amp;gt;n5; n4-&amp;gt;n6; } } a:2:e-&amp;gt;node1:1 [style=dashed]; a:3:e-&amp;gt;node2:1; a:4:e-&amp;gt;root; // node3:d-&amp;gt;node3:sa2; } $$f(a) = \frac{1}{2\pi i} \oint\frac{f(z)}{z-a}dz$$</description>
			<content type="html"><![CDATA[<pre tabindex="0"><code class="language-viz-dot" data-lang="viz-dot">digraph g{
    rankdir=LR;
    node [shape=record,width=01,height=.1];
	a[label=&quot;&lt;1&gt;Hash Table|&lt;2&gt;Node|&lt;3&gt;Node|...|&lt;4&gt;TreeNode&quot;];
    {
        // graph[rankdir=LR]    
        node1[label=&quot;{&lt;1&gt;A1|&lt;2&gt;A2|...|An}&quot;]
        node2[label=&quot;{&lt;1&gt;B1|&lt;2&gt;B2|...|Bn}&quot;]
        // node3[label=&quot;{&lt;1&gt;C1|&lt;2&gt;C2}&quot;]
        subgraph cluster_treenode{
            penwidth=0;
            node[shape=circle];
            root[label=&quot;&quot;, style=filled,fillcolor=black,width=.2];
            n1[label=&quot;&quot;, style=filled,fillcolor=red,width=.2]
            n2[label=&quot;&quot;, style=filled,fillcolor=black,width=.2]
            n3[label=&quot;&quot;, style=filled,fillcolor=black,width=.2]
            n4[label=&quot;&quot;, style=filled,fillcolor=red,width=.2]
            n5[label=&quot;&quot;, style=filled,fillcolor=black,width=.2]
            n6[label=&quot;&quot;, style=filled,fillcolor=black,width=.2]
            root-&gt;n1;
            n1-&gt;n2;
            n1-&gt;n3;
            root-&gt;n4;
            n4-&gt;n5;
            n4-&gt;n6;
        }
    }
    
    a:2:e-&gt;node1:1 [style=dashed];
    a:3:e-&gt;node2:1;    
    a:4:e-&gt;root;    

    // node3:d-&gt;node3:sa2;
}
</code></pre><p>$$f(a) = \frac{1}{2\pi i} \oint\frac{f(z)}{z-a}dz$$</p>
]]></content>
		</item>
		
	</channel>
</rss>
