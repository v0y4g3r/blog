<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>Posts on Tokamako</title>
		<link>https://huanglei.rocks/posts/</link>
		<description>Recent content in Posts on Tokamako</description>
		<generator>Hugo -- gohugo.io</generator>
		<language>en-us</language>
		<copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
		<lastBuildDate>Sat, 12 Mar 2022 17:42:25 +0800</lastBuildDate>
		<atom:link href="https://huanglei.rocks/posts/index.xml" rel="self" type="application/rss+xml" />
		
		<item>
			<title>Notes on InfluxDB Storage Engine</title>
			<link>https://huanglei.rocks/posts/notes-on-influxdb-storage/</link>
			<pubDate>Sat, 12 Mar 2022 17:42:25 +0800</pubDate>
			
			<guid>https://huanglei.rocks/posts/notes-on-influxdb-storage/</guid>
			<description>InfluxDB 的存储引擎经过多次修改，本文描述的系统结构基于 InfluxDB 截止 2022-02-24 的 adf29dfedfc785620db0e104652544ce9f67cb6e 版本。当前版本已经支持 TSI 索引结构。 InfluxDB 的存储系统 InfluxDB 的存储层有三个子系统： TSM：数</description>
			<content type="html"><![CDATA[<blockquote>
<p>InfluxDB 的存储引擎经过多次修改，本文描述的系统结构基于 InfluxDB 截止 2022-02-24 的 <code>adf29dfedfc785620db0e104652544ce9f67cb6e</code> 版本。当前版本已经支持 TSI 索引结构。</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/RayneHwang/img-repo/influxdb-overview.svg" alt="image.png"></p>
<div style="text-align: center;">
<i>
  InfluxDB 的存储系统 
</i>
</div>
<p>InfluxDB 的存储层有三个子系统：</p>
<ul>
<li>TSM：数据点的存储，可以高效地提供 SeriesKey 到时序数据值的插入和检索；</li>
<li>TSI：时序数据的倒排索引，提供查询某个 measurement 下某个 tag 包含特定值的 SeriesID 的接口；
<ul>
<li>TSI 是 InfluxDB 查询引擎的核心，所谓的基数膨胀带来的问题也是出现在这一层。</li>
<li>为了降低 TSI 的内存占用，InfluxDB 引入了一个额外的 SeriesID。</li>
</ul>
</li>
<li>Series 索引：提供根据 SeriesID 查找 SeriesKey 的接口等
<ul>
<li><code>SeriesFile.CreateSeriesListIfNotExists</code>：创建 <code>SeriesKey</code>-&gt;<code>SeriesID</code> 的映射</li>
<li><code>SeriesFile.SeriesKey</code>：根据 SeriesID 查找 SeriesKey</li>
</ul>
</li>
</ul>
<p>应该说 TSI 加上 SeriesIndex 才是 InfluxDB 完整的索引部分，但是这两者各自是一个类 LSMT 的数据结构，也有自己的 WAL、compaction/recover 策略等等，因此 InfluxDB 做了区分。</p>
<p>在 InfluxDB 查询数据时，首先根据用户的查询条件从 TSI 查找到符合条件的 SeriesID，然后从 SeriesIndex 查询对应的 SeriesKey，最后从 TSM 根据 SeriesKey 读取并合并所有的数据点。</p>
<blockquote>
<p>值得额外说明的是，InfluxDB 采用了 Roaring Bitmap 作为压缩的 map 用来存储 SeriesID 等数据；此外用 Robin Hood Hash 用作磁盘上的持久化的 hashtable 的 hash 算法，读取时的 locality 比较好。本文所述的 磁盘文件上的 hash index 都是采用的 RHH。</p>
</blockquote>
<h2 id="tsm">TSM</h2>
<p>TSM 是 InfluxDB 存储时间线数据点的引擎。可以理解为一个 <code> map&lt;SeriesKey, list&lt;DataPoint&gt;&gt;</code> 的数据库。为了提高时间点的写入吞吐，TSM 采用了类似于 LSMT 的数据结构。</p>
<p>InfluxDB 将每个时间段划分为一个 shard，每个 shard 对应底层的一个数据库文件，包括其自己的 WAL 和 TSM 文件。InfluxDB 文档中很多地方把这个 DB 的概念称为 RP（Retention Policy），本质上是因为 RP 决定了 DB 下面的 shard 如何过期清理，一个 DB 只会有一个 RP，因此 RP 实例就是 DB 实例。</p>
<p><img src="https://cdn.jsdelivr.net/gh/RayneHwang/img-repo/tsm-overview.svg#crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;height=588&amp;id=p6Hzv&amp;originHeight=2175&amp;originWidth=1997&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=&amp;width=540" alt=""></p>
<div style="text-align: center;">
<i>
 TSM 文件总览 
</i>
</div>
<h2 id="tsi">TSI</h2>
<p>TSI 提供的能力是 tag 到 series key 的索引，如开头所说，为了降低 TSI 的内存占用，InfluxDB 额外引入了 SeriesID 的概念，这样一来就将 TSI 分为 tag-&gt;id 和 id-&gt;key 两部分，本文分别称为 Index 和 Series。只有两部分加起来才是完整的 InfluxDB 的时序索引。</p>
<p><img src="https://cdn.jsdelivr.net/gh/RayneHwang/img-repo/influxdb-tsi-overview.svg" alt="influxdb-tsi-overview"></p>
<div style="text-align: center;">
<i>
 TSI 索引存储全景 
</i>
</div>
<h3 id="index-部分">Index 部分</h3>
<p>TSI 主要维护的是一个持久化的 <code>map&lt;TagName, map&lt;TagValue, list&lt;SeriesID&gt;&gt;&gt;</code> 数据结构，类似于一个 LSMT 的 KV 系统。</p>
<p>TSI 提供的接口主要是：</p>
<ul>
<li><code>Index.TagValueSeriesIDIterator</code>：根据 measurement、tag key、tag value 找到需要读取的 SeriesID</li>
<li><code>Index.CreateSeriesIfNotExists</code>：根据输入的 measurement、key 和 tag value 创建一个新的</li>
</ul>
<p>和其他的 LSMT 一样，TSI 也有一个 WAL、Memtable、SST。</p>
<ul>
<li>WAL：<code>LogFile</code> 的磁盘部分（.tsl 文件）</li>
<li>MemTable：<code>LogFile</code>的内存部分</li>
<li>SST：<code>IndexFile</code></li>
</ul>
<p>TSI 本身也是 Shard 维度的，这样当旧的 shard 过期之后里面的 索引也会自动删除。</p>
<h4 id="tsl-文件的格式">TSL 文件的格式</h4>
<p><img src="https://cdn.jsdelivr.net/gh/RayneHwang/img-repo/influxdb-tsl-layout.svg" alt="image.png"></p>
<div style="text-align: center;">
<i>
 TSL 文件的布局 
</i>
</div>
<p>TSL 文件是  LogFile 的磁盘表示，由一系列的 LogEntry 组成。当新的 SeriesKey 写入的时候，会在这个 TSL 文件的末尾 append 一个 log entry。每个 log entry 包括：</p>
<ul>
<li>flag：代表这个 entry 所执行的操作，可以是新增/删除 series、删除 measurement、删除 tag key、删除 tag value 之一</li>
<li>series id：series key 的 ID</li>
<li>name：series key 的 name</li>
<li>key：series key 的 tag key</li>
<li>value：series key 的 tag value</li>
<li>checksum：校验和</li>
<li>size：大小</li>
</ul>
<p>当 InfluxDB 实例重启的时候，会通过重放这个 TSL 文件获得一份最新的 series key 数据。</p>
<h4 id="tsi-文件的格式">TSI 文件的格式</h4>
<p><img src="https://cdn.jsdelivr.net/gh/RayneHwang/img-repo/influxdb-tsi-layout.svg" alt="influxdb-tsi-layout"></p>
<div style="text-align: center;">
<i>
 TSI 文件布局 
</i>
</div>
<p>TSI 文件分为三部分，分别是文件尾部的 tailer、measurement block 和 tag block 组成。</p>
<ul>
<li>通过读取 trailer 的数据，可以找到 measurement 对应 的 measurement block 的 offset</li>
<li>通过 measurement block 中的 tag offset 可以找到 tag 对应的 tag block 。除此之外，measurement block 还记录了 measurement  的 cardinality 、SeriesID Set（bitmap）等信息。</li>
<li>tag block 本质上是一个持久化的 hashmap</li>
</ul>
<h5 id="indexfiletailer">IndexFileTailer</h5>
<p><img src="https://cdn.jsdelivr.net/gh/RayneHwang/img-repo/influxdb-tsi-index-trailer.svg" alt="influxdb-tsi-index-trailer.svg"></p>
<h5 id="measurementblocks">MeasurementBlocks</h5>
<p><img src="https://cdn.jsdelivr.net/gh/RayneHwang/img-repo/influxdb-tsi-measurement-block.svg" alt="influxdb-tsi-measurement-block.svg"></p>
<p>MeasurementBlocks 有一系列的 MeasurementBlock、一个 HashIndex 和一个 MeasurementBlockTrailer 组成：</p>
<ul>
<li>MeasurementBlock 保存的是 measurement 的数据</li>
<li>HashIndex 保存的是每一个 MeasurementBlock 在文件的偏移量</li>
<li>MeasurementBlockTrailer 记录了在 MeasurementBlock 数据区的起始 offset 和 size、HashIndex 的起始 offset 和 size 以及 sketch、tsketch 的起始 offset 和 size 信息。</li>
</ul>
<h5 id="tagblocks">TagBlocks</h5>
<p><img src="https://cdn.jsdelivr.net/gh/RayneHwang/img-repo/influxdb-tsi-tag-block.svg" alt="influxdb-tsi-tag-block"></p>
<div style="text-align: center;">
<i>
Tag block 存储格式
</i>
</div>
<p>TagBlocks 保存的是某个 tag key 下面的所有 tag value 以及这个 tag value 对应的 series id 列表。TagBlock 通过一个多级的 map 去维护了这样的双重映射关系。</p>
<ul>
<li>首先在 TagBlockTrailer 这个尾部的数据结构维护了 tag value section、tag key section、tag key array map 的地址；</li>
<li>通过 trailer 的 hash index offset 可以找到 tag key block 的 hash index （下图中的 1）；</li>
<li>遍历 hash index 可以找到所需要某个 tag key 的 tag key block entry （下图中的 2）；</li>
<li>通过 tag key block entry 的 tag hash index offset 可以找到 这个 key 对应的 tag value 的 hash index 部分的地址 （下图中的 3）；</li>
<li>遍历这个 tag value block 的 tag value hash index 可以找到符合条件的 tag value entry 的地址，从而读取到这个 tag value 的数据，包括 series id 等（下图中的 4）。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/RayneHwang/img-repo/influxdb-tsi-tag-lookup.png" alt="influxdb-tsi-tag-lookup.png"></p>
<h4 id="根据-tag-key-和-tag-value-查找">根据 Tag key 和 Tag value 查找</h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-latex" data-lang="latex"><span class="line"><span class="cl">Index.TagValueSeriesIDIterator 						@tsdb/index/tsi1/index.go:999
</span></span><span class="line"><span class="cl"><span class="k">\-</span>-- Partition.TagValueSeriesIDIterator 	@tsdb/index/tsi1/index.go:1010
</span></span><span class="line"><span class="cl">    <span class="k">\-</span>-- IndexFile.TagValueSeriesIDSet 		@tsdb/index/tsi1/partition.go:805
</span></span><span class="line"><span class="cl">        <span class="k">\-</span>-- TagBlock.DecodeTagValueElem	@tsdb/index/tsi1/index<span class="nb">_</span>file.go:335
</span></span><span class="line"><span class="cl">              <span class="nb">^</span>~ 这里的 tagblocks 在启动的时候就会从磁盘上的 IndexFile 读取到IndexFile.tblks 中来，
</span></span><span class="line"><span class="cl">                  而 IndexFile 之外的变更保留在 LogFile 的内存索引中
</span></span></code></pre></div><h4 id="index-compaction">Index Compaction</h4>
<p>TSI 索引的 compaction 有两类：</p>
<ul>
<li>LogFile -&gt; IndexFile: <code>LogFile.Compact</code>，即 level 0 到 level 1 的 compaction，把 TSL 文件压缩成 TSI 文件</li>
<li>IndexFile leveled compaction: <code>IndexFiles.Compact</code>，即 level n 到 level n+1 的 compaction</li>
</ul>
<h3 id="series-索引">Series 索引</h3>
<p><img src="https://cdn.jsdelivr.net/gh/RayneHwang/img-repo/influxdb-series-index-overview.svg" alt="influxdb-series-index-overview.svg"></p>
<div style="text-align: center;">
<i>
 Series 索引全景图 
</i>
</div>
<p>Series 索引主要负责 SeriesKey 到 SeriesID 和 SeriesID 到 SeriesOffset 的映射，可以理解为一个持久化的 <code>map&lt;SeriesID, SeriesKey&gt;</code>。Series 索引也是 database 维度的。Series 索引分为三个部分：</p>
<ul>
<li>&ldquo;WAL&rdquo;：SeriesSegment</li>
<li>&ldquo;MemTable&rdquo;：SeriesIndex 的内存部分</li>
<li>&ldquo;SST&rdquo;：SeriesIndex 持久化到磁盘的部分（在启动的时候会通过 mmap 载入）</li>
</ul>
<p>理解 Series 索引的核心在于理解 SeriesIndex 和 SeriesSegment 的交互。</p>
<p>SeriesIndex 相当于是 Memtable，SeriesSegment 相当于是 WAL。SeriesSegment 里面保存的都是具体针对 series 的操作（operation），只要在 recover 的时候把 SeriesSegment 里面的数据重放一遍就可以了（见<code>SeriesIndex.Recover</code>）。<strong>为了减小 SeriesIndex 的内存占用，InfluxDB 做了 KV 分离</strong>，真实的 value（即Series Key） 都是保存在 “WAL”（SeriesSegment） 中的，“memtable”（即 SeriesIndex） 中的 value 只是指向  SeriesSegment 当中一个地址的 offset。</p>
<p>和其他 LSMT 类似，SeriesIndex 也需要做 compact，compact 的逻辑就是 遍历 SeriesPartition 下面的所有的 segment 里面的所有 entry，把存活的 series 写到 series index 文件中。具体的 compact 逻辑是在<code>SeriesPartitionCompactor.compactIndexTo</code>中，为了实现 series 的删除，也在 compact 的时候判断是 series 是否已经被标记为 deleted。</p>
<blockquote>
<p>为什么需要 SeriesID？如果直接在内存里面维护 SeriesKey 到 Series 的映射，则内存里面会多很多的 tag key 和 tag value 拼接而成的数据，而且这个数据会有大量的冗余。SeriesID 相当于合并了这部分冗余的数据。</p>
</blockquote>
<h4 id="seriesindex">SeriesIndex</h4>
<p><img src="https://cdn.jsdelivr.net/gh/RayneHwang/img-repo/influxdb-series-index-file-layout.svg" alt="influxdb-series-index-file-layout.svg"></p>
<div style="text-align: center;">
<i>
SeriesIndex 的数据组成
</i>
</div>
<p>SeriesIndex 分为两部分，一部分是保存在内存上的：<code>SeriesIndex.keyIDMap</code>/<code>SeriesIndex.idOffsetMap</code>/<code>SeriesIndex.tombstones</code>，另一部分是保存在磁盘上的：<code>SeriesIndex.keyIDData</code> /<code>SeriesIndex.idOffsetData</code>。</p>
<p>SeriesIndex 磁盘文件里面的 series 数据可以理解为基线数据。在启动的时候，InfluxDB 会把磁盘上面的 Series Index 文件里面的内容加在到 <code>SeriesIndex.keyIdData</code>和 <code>SeriesIndex.idOffsetData</code>中（通过 mmap 的方式），这块文件里面的内容实际上就是一个持久化的 HashMap。InfluxDB 会定期地把 内存的数据（<code>SeriesIndex.keyIDMap</code>和 <code>SeriesIndex.idOffsetMap</code>等）和磁盘的基线数据合并形成一个新的基线数据。</p>
<h4 id="seriessegment">SeriesSegment</h4>
<p><img src="https://cdn.jsdelivr.net/gh/RayneHwang/img-repo/influxdb-series-segment-file-layout.svg" alt="influxdb-series-segment-file-layout.svg"></p>
<div style="text-align: center;">
<i>
 SeriesSegment 的二进制格式 
</i>
</div>
<p>SeriesSegment 就是一组磁盘上的文件，由一个 header 和椅子列的 SeriesEntry 组成，每个 Entry 可能是一个 insert entry（代表 SeriesKey 的插入）或者 tombstone entry （代表 series key 的删除）。在启动的时候会通过 mmap 的方式把 segments 加载进来，每次创建新的 Series Key 的时候也会向这个 mmap 的文件的末尾去 append 一个新的 series entry。</p>
<p>如上介绍，SeriesIndex 内部维护的并不是 SeriesID 到 SeriesKey 的映射，真正的 SeriesKey 是保存在 WAL 即 SeriesSegment 上面的，因此 SeriesIndex 额外引入了一个 offset 去表明 SeriesKey 在 SeriesSegment 上的 地址。</p>
<h4 id="seriesoffset">SeriesOffset</h4>
<p><img src="https://cdn.jsdelivr.net/gh/RayneHwang/img-repo/influxdb-series-offset.svg" alt="influxdb-series-offset.svg"></p>
<div style="text-align: center;">
<i>
 SeriesOffset 格式
</i>
</div>
<p>SeriesOffset 指向的是一个 series entry 在 series segments 中的地址，是一个 64 位值，由两部分组成，高 32 位（实际上只会有 16 位使用，足够寻址 2^16 个 segment)是 segment id ，低 32 位是 series entry 在此 id 的 series segment 中的偏移量。因此通过 SeriesOffset 可以唯一地找到 segment 以及其中 entry 的位置。</p>
<blockquote>
<p>Series Offset 的拼接和拆分见<code>JoinSeriesOffset</code>和 <code>SplitSeriesOffset</code>两个函数</p>
</blockquote>
<h4 id="查找路径">查找路径</h4>
<ul>
<li>根据 SeriesKey 查找 SeriesID：首先在内存的<code>SeriesIndex.keyIDMap</code>查找，如果没有则<strong>遍历</strong> SeriesSegment 下面的所有 SeriesEntry，找到 Key 匹配的 ID 返回</li>
<li>根据 SeriesID 查找 SeriesKey：<code>SeriesPartition.SeriesKey</code>。首先根据 series id 找到 series offset，然后根据 series offset 找到 series key。
<ul>
<li>根据 id 找到 offset 首先也是从 内存的 <code>SeriesIndex.idOffsetMap</code>读取，如果没有就去 SeriesIndex 的磁盘部分读取（遍历 <code>SeriesIndex.idOffsetData</code>查找）</li>
<li>根据 offset 找到 key：把 offset 分割为 SegmentID 和 pos 两部分，从 Segment ID 可以找到 磁盘上的 SeriesSegment 文件，接着这个 SeriesSegment 的 pos 位置的数据（Uvarint+string）就是对应的 series key。</li>
</ul>
</li>
</ul>
<h3 id="high-cardinality-问题是如何出现的">High Cardinality 问题是如何出现的</h3>
<p>InfluxDB 最为人诟病的问题就是所谓的 high cardinality 问题，即当 InfluxDB 实例写入大量的不同 tag value 的时候，时间线数量会大幅膨胀。</p>
<p>考虑某个 measurement 有三个 tag: HostName, AZ, Region，分别代表一个服务器的机器名、可用区和 region。其中 HostName 可能出现 100 个值，AZ 可能 出现 20 个值，Region 可能出现 10 个值，那么这个 measurement 可能出现的总时间线数量（即所谓的 cardinality）为 100<em>20</em>10=20000，即所有 tag 值空间大小的笛卡尔积。</p>
<p>当时序数据的 cardinality 增长的时候，InfluxDB 内部的倒排索引会大幅膨胀。InfluxDB 历史上为了解决倒排索引膨胀的问题采取了多种策略，比如通过 SeriesID 降低倒排索引的大小，将<a href="https://github.com/influxdata/influxdb/issues/7151">纯内存存储的倒排索引优化为内存+磁盘的索引</a>（即本文的 TSI 引擎）等等。但是这些手段都是延缓倒排出现性能瓶颈的时间。除此之外，Series Index 部分（即 SeriesID 到 SeriesKey 的正排索引）在大量时间线的情况下也会出现性能瓶颈。比如 Series 索引在做 compaction 的时候（<code>SeriesPartitionCompactor.Compact</code>）一方面会遍历 SeriesSegment 文件中的所有 entry 去 apply 到内存的 hashmap，再把内存中的数据写入到磁盘上的 SeriesIndex 文件中。假设 Series 数量很大，那么这个 compact 过程很有可能出现 OOM。</p>
<p>目前可以想到的一个简单的缓解办法是现在 RP 维度的 Series 索引变成 RP 下面的 Shard 维度的，当 Shard 过期之后会自动把相应的 Series 索引过期。</p>
]]></content>
		</item>
		
		<item>
			<title>Apache Parquet 格式简介</title>
			<link>https://huanglei.rocks/posts/parquet/</link>
			<pubDate>Sat, 05 Mar 2022 15:44:33 +0800</pubDate>
			
			<guid>https://huanglei.rocks/posts/parquet/</guid>
			<description>简介 Parquet 是一种面向列的数据存储格式，在 Hadoop 生态中使用广泛。Parquet 文件是不可变的，如果需要修改，只能通过 rewrite 的方式实现。 数据 layout 一个 Parquet 文件的数</description>
			<content type="html"><![CDATA[<h2 id="简介">简介</h2>
<p>Parquet 是一种面向列的数据存储格式，在 Hadoop 生态中使用广泛。Parquet 文件是不可变的，如果需要修改，只能通过 rewrite 的方式实现。</p>
<h2 id="数据-layout">数据 layout</h2>
<p>一个 Parquet 文件的数据布局如下图所示。需要注意的是，官网上的这个图并没有包含 index pages。</p>
<p><img src="https://raw.githubusercontent.com/apache/parquet-format/master/doc/images/FileLayout.gif#crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;id=gFbsV&amp;originHeight=478&amp;originWidth=601&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p>
<div style="text-align: center;">
<i>
 官方的格式图  
</i>
</div>
<p><img src="https://cdn.jsdelivr.net/gh/RayneHwang/img-repo/parquet-original.svg" alt="parquet-original.svg"></p>
<div style="text-align: center;">
<i>
 原始行格式的数据  
</i>
</div>
<p><img src="https://cdn.jsdelivr.net/gh/RayneHwang/img-repo/parquet-travel.svg" alt="parquet-travel.svg"></p>
<div style="text-align: center;">
<i>
 Parquet 数据的遍历顺序 
</i>
</div>
<p><img src="https://cdn.jsdelivr.net/gh/RayneHwang/img-repo/parquet-layout.svg" alt="parquet-layout.svg"></p>
<div style="text-align: center;">
<i>
 使用 Parquet 转换之后的格式 
</i>
</div>
<p>在 Parquet 中，数据每隔若干行被分作一个 row group；在同一个 row group 中，不同 row 的相同列被连续存储在一起。连续的列再间隔若干行会被分割为一个页（page）。</p>
<h2 id="元数据">元数据</h2>
<p><img src="https://cdn.jsdelivr.net/gh/apache/parquet-format/doc/images/FileLayout.gif" alt="image.png"></p>
<p>从如上的 Parquet 格式可以看出来，一个 Parquet 文件是包含了一些元数据的，比如 footer、page header 等等，这些元数据可以在读取 parquet 文件的时候提供相关信息来加速遍历。</p>
<h3 id="footer">Footer</h3>
<p>Footer 是整个 Parquet 文件的元数据，从 footer 可以得到文件的版本、数据 schema、row group 的元数据、row group 中的每一列的元数据等等。</p>
<p>Footer 位于 Parquet 的末尾，因此可以从文件结尾 seek 到倒数第 8 到倒数第 4 字节，作为 footer 的长度，从而得到 footer 区的起始 offset。</p>
<p>Footer 区数据遵循特定的编码格式（ThriftCompactProtocol），因此可以方便地反序列化。</p>
<p>Footer 区还包含了 row group 和 row group 中的列的信息。</p>
<h3 id="列的元数据">列的元数据</h3>
<p><img src="https://cdn.jsdelivr.net/gh/RayneHwang/img-repo/20220305160426.png" alt=""></p>
<div style="text-align: center;">
<i>
  列的元数据位置  
</i>
</div>
<p>在 footer 中，每一列的信息也被记录，包括：</p>
<ul>
<li>列的类型、编码；</li>
<li>列值的数量；</li>
<li>第一个数据页的 offset；</li>
<li>第一个索引页的 offset；</li>
<li>压测/解压缩的大小；</li>
<li>以及一些额外的键值对。</li>
</ul>
<p>根据 footer 中的这些列的信息就可以快速找到 Parquet 文件中的数据地址和索引地址、以及如何解析这些数据。</p>
<h3 id="文件内索列">文件内索列</h3>
<p><a href="https://issues.apache.org/jira/browse/PARQUET-1201">Parquet 2.5 版本</a>支持了列值索引功能，具体的功能介绍可以参考 <a href="https://github.com/apache/parquet-format/blob/master/PageIndex.md">ColumnIndex Layout to Support Page Skipping</a>.</p>
<p>在之前的版本中，统计数据（min、max）只在 column 的 metadata 和 page header 当中，当读取 page 的时候，可以根据 page header 中的统计数据决定是否需要跳过这一页，但这样还是需要遍历文件中的每一页。</p>
<p>目标：通过 minmax 可以直接定位到 page 的方式提高范围查询和点查的 IO 效率。具体来说针对 row group 排序列的单行查询，每一列只需要读取一页数据。排序列的范围查询只读取范围所涉及的数据页；如果其他的查询具有高选择性，即使查询条件不是排序列，也要能够按需读取数据页。</p>
<p>为了实现这样的目标，Parquet 在 row group 的元数据上增加了如下两个针对列的数据结构（即在一个 row group 中的每一个列都有下面的两个索引来描述它们）：</p>
<ul>
<li>ColumnIndex：针对 scan predicate，支持通过列值找到列的数据所在的页；</li>
<li>OffsetIndex：通过 ColumnIndex 找到 match 的 row 之后，OffsetIndex 支持按 row index 去获取相应的值。一个 row group 的所有 column 的 OffsetIndex 都是存储在一起的。</li>
</ul>
<p>索引的地址在 footer 区之前的地方，footer 里面有一个字段指明了其 offset。</p>
<p><img src="https://cdn.jsdelivr.net/gh/RayneHwang/img-repo/parquet-file-format.svg" alt=""></p>
<div style="text-align: center;">
<i>
 Index page 的位置 
</i>
</div>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="sd">/// Description for ColumnIndex.
</span></span></span><span class="line"><span class="cl"><span class="sd">/// Each &lt;array-field&gt;[i] refers to the page at OffsetIndex.page_locations[i]
</span></span></span><span class="line"><span class="cl"><span class="sd"></span><span class="cp">#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">ColumnIndex</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="sd">/// A list of Boolean values to determine the validity of the corresponding
</span></span></span><span class="line"><span class="cl"><span class="sd"></span><span class="w">  </span><span class="sd">/// min and max values. If true, a page contains only null values, and writers
</span></span></span><span class="line"><span class="cl"><span class="sd"></span><span class="w">  </span><span class="sd">/// have to set the corresponding entries in min_values and max_values to
</span></span></span><span class="line"><span class="cl"><span class="sd"></span><span class="w">  </span><span class="sd">/// byte[0], so that all lists have the same length. If false, the
</span></span></span><span class="line"><span class="cl"><span class="sd"></span><span class="w">  </span><span class="sd">/// corresponding entries in min_values and max_values must be valid.
</span></span></span><span class="line"><span class="cl"><span class="sd"></span><span class="w">  </span><span class="k">pub</span><span class="w"> </span><span class="n">null_pages</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="sd">/// Two lists containing lower and upper bounds for the values of each page.
</span></span></span><span class="line"><span class="cl"><span class="sd"></span><span class="w">  </span><span class="sd">/// These may be the actual minimum and maximum values found on a page, but
</span></span></span><span class="line"><span class="cl"><span class="sd"></span><span class="w">  </span><span class="sd">/// can also be (more compact) values that do not exist on a page. For
</span></span></span><span class="line"><span class="cl"><span class="sd"></span><span class="w">  </span><span class="sd">/// example, instead of storing &#34;&#34;Blart Versenwald III&#34;, a writer may set
</span></span></span><span class="line"><span class="cl"><span class="sd"></span><span class="w">  </span><span class="sd">/// min_values[i]=&#34;B&#34;, max_values[i]=&#34;C&#34;. Such more compact values must still
</span></span></span><span class="line"><span class="cl"><span class="sd"></span><span class="w">  </span><span class="sd">/// be valid values within the column&#39;s logical type. Readers must make sure
</span></span></span><span class="line"><span class="cl"><span class="sd"></span><span class="w">  </span><span class="sd">/// that list entries are populated before using them by inspecting null_pages.
</span></span></span><span class="line"><span class="cl"><span class="sd"></span><span class="w">  </span><span class="k">pub</span><span class="w"> </span><span class="n">min_values</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">u8</span><span class="o">&gt;&gt;</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="k">pub</span><span class="w"> </span><span class="n">max_values</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">u8</span><span class="o">&gt;&gt;</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="sd">/// Stores whether both min_values and max_values are orderd and if so, in
</span></span></span><span class="line"><span class="cl"><span class="sd"></span><span class="w">  </span><span class="sd">/// which direction. This allows readers to perform binary searches in both
</span></span></span><span class="line"><span class="cl"><span class="sd"></span><span class="w">  </span><span class="sd">/// lists. Readers cannot assume that max_values[i] &lt;= min_values[i+1], even
</span></span></span><span class="line"><span class="cl"><span class="sd"></span><span class="w">  </span><span class="sd">/// if the lists are ordered.
</span></span></span><span class="line"><span class="cl"><span class="sd"></span><span class="w">  </span><span class="k">pub</span><span class="w"> </span><span class="n">boundary_order</span>: <span class="nc">BoundaryOrder</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="sd">/// A list containing the number of null values for each page *
</span></span></span><span class="line"><span class="cl"><span class="sd"></span><span class="w">  </span><span class="k">pub</span><span class="w"> </span><span class="n">null_counts</span>: <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">i64</span><span class="o">&gt;&gt;</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="cp">#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">OffsetIndex</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="sd">/// PageLocations, ordered by increasing PageLocation.offset. It is required
</span></span></span><span class="line"><span class="cl"><span class="sd"></span><span class="w">  </span><span class="sd">/// that page_locations[i].first_row_index &lt; page_locations[i+1].first_row_index.
</span></span></span><span class="line"><span class="cl"><span class="sd"></span><span class="w">  </span><span class="k">pub</span><span class="w"> </span><span class="n">page_locations</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">PageLocation</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><h2 id="parquet-的优势">Parquet 的优势</h2>
<ul>
<li>按需读取列的值，比如在 OLAP 场景下，大宽表往往最终只有少量的列会被读取到；</li>
<li>自描述，自带 schema，支持数据结构嵌套；</li>
<li>由于列保存在一起，因此可以提高压缩和编码的效率（比如 RLE、字典压、Bit Packing 等等）;</li>
<li>文件自带索引，支持快速检索 data page。</li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>BookKeeper 笔记</title>
			<link>https://huanglei.rocks/posts/bookkeeper-note/</link>
			<pubDate>Thu, 24 Feb 2022 01:18:35 +0800</pubDate>
			
			<guid>https://huanglei.rocks/posts/bookkeeper-note/</guid>
			<description>BookKeeper 的使用场景 WAL：比如 HDFS Namenode 的 EditLog（要求高可靠） 分布式存储：比如 Pulsar 的消息存储、DistributedLog 等 核心理念 通过条带化写（</description>
			<content type="html"><![CDATA[<h1 id="bookkeeper-的使用场景">BookKeeper 的使用场景</h1>
<ul>
<li>WAL：比如 HDFS Namenode 的 EditLog（要求高可靠）</li>
<li>分布式存储：比如 Pulsar 的消息存储、DistributedLog 等</li>
</ul>
<h1 id="核心理念">核心理念</h1>
<ul>
<li>通过条带化写（Data Striping）实现数据的多副本，所有存储节点角色对等；</li>
<li>通过其他的存储组件（ZooKeeper）实现元数据高可靠，故障恢复（recover）流程强依赖 ZK 的元数据；
<ul>
<li>也可以选用其他的存储服务，要求 1. CP 系统；2. 提供 CAS 原语</li>
</ul>
</li>
<li>基于 RocksDB 提供 <code>(ledger, sequence) -&gt; (file, physicalOffset)</code>  的索引（<code>SingleDirectoryDbLedgerStorage#ledgerIndex</code>）；</li>
<li>同一时刻只有一个 writer 和多个 reader，通过 fencing 机制避免出现多 writer，避免 sequence 乱序；</li>
<li>读写分离，冷热分离（tailing read/catch-up read）提高吞吐；</li>
</ul>
<h1 id="bookkeeper-的术语">BookKeeper 的术语</h1>
<ul>
<li>ledger：一写多读的 append-only 文件，ledger 的最小数据单元是 fragment；</li>
<li>bookie：存储 ledger 的节点；</li>
<li>ledger has many records， called：entry，每个entry都有一个 sequence number，可以根据 ledger + seq 来读取一部分 entry。</li>
<li>quorum：几个 bookie 组成一个 quorum，通过复制提高可用性。</li>
<li>data striping：数据块交织写入到各个设备，提高写入的性能。类似 RAID1 的机制。</li>
</ul>
<p><img src="https://huanglei-rocks-blog.oss-cn-shanghai.aliyuncs.com/blog/20220224230803.png" alt=""></p>
<div style="text-align: center;">
<i>
 BookKeeper 的 quorum write 机制 
</i>
</div>
<p>Striping 很容易就会导致读取者所看到的 log 不一致，因此 BK 引入了 ZK 去保存元数据，并且通过 triming 机制（BK 称为 reader-initiated ledger recovery）来确保末尾未完整写完整个 quorum 的数据能够被安全删除并且对 reader 不可见。</p>
<h1 id="实现细节">实现细节</h1>
<h2 id="bookie-的结构">Bookie 的结构</h2>
<p>Bookie 是存储节点，具体包含两个模块：</p>
<ul>
<li>journal：WAL，同步写，负责保存 writer 的写入操作；</li>
<li>ledger：包含内存的状态（memtable）、ledger 的索引等，异步写。</li>
</ul>
<p><img src="https://huanglei-rocks-blog.oss-cn-shanghai.aliyuncs.com/blog/20220224231150.png" alt=""></p>
<div style="text-align: center;">
<i>
 BookKeeper 的读写路径 
</i>
</div>
<p>理想状况下，journal 和 ledger 应该位于不同的磁盘上，减少他们同时不可用的概率。</p>
<h2 id="bookkeeper-提供的-api">BookKeeper 提供的 API</h2>
<ul>
<li>创建 ledger</li>
<li>向 ledger 新增 entry</li>
<li>打开一个 ledger</li>
<li>从ledger 读取 entry</li>
<li>关闭 ledger 避免后续数据写入</li>
<li>删除一个ledger</li>
</ul>
<h2 id="ledger-操作">Ledger 操作</h2>
<h3 id="ledger-创建">Ledger 创建</h3>
<p>一个 ledger 需要由一个 ensemble 来负责，因此创建 ledger 的时候必须指定 ledger 的 quorum 和 ensemble。具备 f+1 个节点的 quorum 可以容忍 f 个节点宕机。</p>
<ul>
<li>quorum：写入节点集合。更大的quorum 提供更强的可用性。</li>
<li>ensemble：striping 所需要的节点总数。更大的 ensemble 提供更大的吞吐。</li>
</ul>
<p><img src="https://huanglei-rocks-blog.oss-cn-shanghai.aliyuncs.com/blog/paper-creating-using-ledger.png?versionId=CAEQIBiBgMDlsZax.RciIGJmZGJjYjRjODNiZjQ4ZDE4OWZkMjVlZWRhNmEzMGJh" alt="paper-creating-using-ledger.png"></p>
<ul>
<li>quorum 是以 round-robin 的形式分散在整个 ensemble 中。</li>
<li>quorum 和 ensemble 这些元数据保存在 zookeeper 中。</li>
</ul>
<blockquote>
<p>这里有个问题，当bk客户端尝试读取 entry 的时候，需要确定从哪些bookie组成的quorum 读取，那这个quorum是怎么确定的？</p>
</blockquote>
<p><img src="https://huanglei-rocks-blog.oss-cn-shanghai.aliyuncs.com/blog/paper-to-read-a-given-entry-e.png?versionId=CAEQIBiBgICTgJmx.RciIGNmMjU4OWFmYTE0YjQ4NzFiNjY0MTM4NzRjZjNjZTJi" alt="image.png"></p>
<h3 id="ledger-关闭">Ledger 关闭</h3>
<p>Ledger 关闭是一个原子的操作，会在 ZK 中记录 ledger 最后一个 entry 的 seq。这里ZK 提供的一致性协议非常重要，否则 Bookkeper 的客户端可能会观察到 ledger 的 不一致。
<img src="https://huanglei-rocks-blog.oss-cn-shanghai.aliyuncs.com/blog/1635067390415-cdc4ede3-9bd7-4bd3-82e7-f3c3091be3d1.png" alt="paper-closing-a-ledger">
当 BK 的客户端没有 close 一个ledger 就 crash 怎么办？因此需要一个额外的机制来保证所有 open 的ledger 都能够最终被 close。</p>
<h3 id="ledger-的恢复">Ledger 的恢复</h3>
<p>Ledger 的写入者可能在没关闭 ledger 的时候就 crash 了，这种情况下 entry 的元数据尚未更新到 zk中， ledger 的读取者无法安全地确认 ledger中的最后的 entry 是什么，因此 ledger 需要 恢复操作（recovery）。</p>
<p>当 reader 打开一个 ledger 读取的时候，从 ZK 中获取元数据，同时如果发现这个 ledger 尚未被 close，就触发一个 recovery 流程。</p>
<p>Recovery：确定按所要求的 quorum 写入成功的最后一个 entry，写入到 ZK 中。</p>
<blockquote>
<p>如何确认最后一个 entry？可以简单地从 ledger 一次读取所有的entry，重新写入一遍。
为了加速，reader 向 ensemble 中所有的 bookie 询问 此ledger 写入的最新的 entry 的LAC字段（Last Add Confirmed）。然后恢复流程就可以从最高的 LAC 位置开始，而无需读取整个 ledger。</p>
</blockquote>
<h3 id="lac">LAC</h3>
<p>LAC：Last add confirmed，获取一个 quorum 中最后一个被确认写入的 entry 的 id
对于 单个 bookie 而言，所谓的LAC就是当前 ledger 最后一个写入的 entry 的 entry id。而对于客户端而言，获取quorum 的LAC就是获取整个 quorum 中最大的LAC。</p>
<p><strong>这里比较容易混淆：LAC 应该是维护在 writer 本地的，只是每次写入到 bookie 的时候把它放在 entry 的某个字段中。Quorum 中所有 bookie 的最后一个 entry 的 LAC 最大值，所反映的一定是这个 writer 的 LAC 的最大值，这样一来 LAC 的作用就好理解了，相当于是把 writer 的写入确认水位状态随着 entry 写入到了每一个 bookie中。</strong></p>
<blockquote>
<p><strong>这块的介绍可以看 <strong><a href="https://bookkeeper.apache.org/distributedlog/docs/latest/user_guide/design/main.html"><strong>DistributedLog</strong></a></strong>。</strong></p>
</blockquote>
<h1 id="fencing">Fencing</h1>
<p>LAC 只能保证 reader 之间读取的一致性，但是不能避免出现多个 writer。</p>
<p>bookie 检测到某个 ledger 出于 recovery 流程中时，拒绝掉所有这个ledger 写入的请求。</p>
<h3 id="从一个-open-状态的-ledger-读取数据">从一个 open 状态的 ledger 读取数据</h3>
<p>前述都是基于 reader 只能读取 closed 的 ledger 的前提。但是 reader完全有可能需要读取 open 的ledger（废话。。。），因此 BK 提供了绕过了 recovery 流程的读取API。在这个API 中，为了防止 reader 读取到 transient entry（只在 quorum 中复制了一部分，关闭 ledger 后可能会被 trim 掉的 entry），reader会向bookie 查询 ledger 的 LAC，读取 LAC 以前的 entry 是安全的，因为他们都已经被完整地复制了。</p>
<p>Ledger device：第一版不同的 ledger 有不同的文件，后来改为一个（类似RocketMQ的CommitLog），成为entry log。原因是多个文件的随机写入带来的磁盘寻道、Page cache 的竞争大大降低了写入吞吐。不同 ledger 的 entry 都存储在一个 entry log 中。</p>
<p><img src="https://cdn.jsdelivr.net/gh/RayneHwang/img-repo/bookkeeper-write.svg?" alt=""></p>
<div style="text-align: center;">
<i>
 Journal to Ledger Log 
</i>
</div>
<p>对于每个ledger，bookie 在 ledger device 上还维护了一个索引，并且把这个索引 映射 到内存，降低索引构建导致的 IO 开销。</p>
<p>Ledger 的设计主要针对写为主的流量。读的场景下，如果命中了内存中的ledger index，那么只需要一次磁盘 IO，否则需要先从 Ledger index文件找到 entry 所在 entry log 中的位置，然后再去 entry log 中读取entry内容。</p>
<h2 id="源码分析">源码分析</h2>
<h3 id="entry-的写入">Entry 的写入</h3>
<p><img src="https://huanglei-rocks-blog.oss-cn-shanghai.aliyuncs.com/blog/entry-write-diagram.png" alt="entry-write-diagram.png"></p>
<div style="text-align: center;">
<i>
 Entry 写入的流程 
</i>
</div>
<h3 id="entry-的读取">Entry 的读取</h3>
<p>还是根据 write set 找到负责 entry 的 bookie 列表，然后向这些 bookie 发送读取请求。</p>
<p>Entry 读取的时候可能存在一种特殊情况：读取的 entry 范围一jnkmlxc部分落在一个 ensemble，一部分落在另一个 ensemble，比如下面图中的情况。</p>
<p><img src="https://huanglei-rocks-blog.oss-cn-shanghai.aliyuncs.com/blog/20220228234606.png" alt="entry scatter"></p>
<div style="text-align: center;">
<i>
 尝试读取散落在不同 ensemble 的 entry 
</i>
</div>
<p>为了处理读取散落在不同 ensemble 的 entry 的情况，BookKeeper 每次读取 entry 前都会判断所读取的 entry id 是否出现 ensemble change。</p>
<p><img src="https://cdn.jsdelivr.net/gh/RayneHwang/img-repo/Bookkeeper.drawio.svg?" alt=""></p>
<div style="text-align: center;">
<i>
 Entry 读取的主流程代码 
</i>
</div>
<p>为了避免部分慢节点导致延迟升高，提升读取的性能，BookKeeper 客户端还采用了 speculative read（推测读取）的方式，如果当前读取的 bookie 没有在特定时间内返回数据，那么客户端会立刻尝试向另一个 bookie 发送读取请求，并同时等待两个 bookie 的响应。具体可见 <a href="https://bookkeeper.apache.org/docs/4.5.0/api/javadoc/org/apache/bookkeeper/client/DefaultSpeculativeRequestExecutionPolicy.html">DefaultSpeculativeRequestExecutionPolicy</a>.</p>
]]></content>
		</item>
		
		<item>
			<title>LSM Tree 笔记</title>
			<link>https://huanglei.rocks/posts/note-on-lsmt/</link>
			<pubDate>Thu, 10 Feb 2022 22:34:39 +0800</pubDate>
			
			<guid>https://huanglei.rocks/posts/note-on-lsmt/</guid>
			<description>写入（Write path） 先从磁盘（HDD）写入的特性引入 append-only 的 WAL。 对于 KV 结构，如果写入是 append only的，那么就需要合并，不然读取性能太差。</description>
			<content type="html"><![CDATA[<h2 id="写入write-path">写入（Write path）</h2>
<ul>
<li>
<p>先从磁盘（HDD）写入的特性引入 append-only 的 WAL。</p>
</li>
<li>
<p>对于 KV 结构，如果写入是 append only的，那么就需要合并，不然读取性能太差。</p>
</li>
<li>
<p>单文件合并性能差，因此需要按阈值切分为多个小文件，通过归并排序的思路优化合并的效率。</p>
</li>
<li>
<p>多路归并要求每个文件有序，为了保证每个文件有序，就需要，数据写入的时候，不直接把 operation 直接写入到磁盘，而是先在内存缓存一段时间，并且在内存排好序，然后再一次把整个文件 flush 到磁盘。</p>
<ul>
<li>内存有序的数据结构：跳表、红黑树、B+ 树</li>
<li>buffer 在内存的数据丢了怎么办？先写 redo log</li>
</ul>
</li>
</ul>
<h2 id="有序数据结构">有序数据结构</h2>
<p><img src="https://gw.alipayobjects.com/zos/antfincdn/V8oKiYS5z/1639280343.png" alt=""></p>
<blockquote>
<p><a href="https://github.com/facebook/rocksdb/wiki/MemTable">RocksDB 的数据结构比较</a>：选择跳表的原因是跳表支持并发插入。</p>
</blockquote>
<p>LSMT 的数据分类</p>
<ul>
<li>内存数据：MemTable</li>
<li>磁盘数据：SSTable（Sorted Sequence Table）</li>
<li>日志：redo log</li>
</ul>
<h2 id="内存数据组织">内存数据组织</h2>
<p>内存的数据需要保证有序，同时支持高性能的插入和查找。</p>
<ul>
<li>ART：自适应基树（比如 Bitcask 采用）；</li>
<li>SkipList：LevelDB、RocksDB 等。</li>
</ul>
<h2 id="sstable-文件格式">SSTable 文件格式</h2>
<p>按 Block 进行存储，可以参考 LevelDB 和 RocksDB 的 SST 文件的格式。</p>
<h2 id="合并策略">合并策略</h2>
<ul>
<li>
<p>分级合并（Leveling Merge Policy）</p>
<ul>
<li>每一级都有且只有一个文件</li>
</ul>
</li>
<li>
<p>分层合并 (Tiering Merge Policy)</p>
<ul>
<li>每一级有多个小文件，每个小文件中的 key 不重叠（LevelDB 和 RocksDB采用，尽管他们称自己为 leveling merge）</li>
</ul>
</li>
<li>
<p>合并时间：定时合并、达到阈值合并。</p>
</li>
</ul>
<h2 id="读取read-path">读取（Read path）</h2>
<p>核心原则：先热后冷读取最新的数据，一旦读取到就停止。</p>
<ul>
<li>优先读取 MemTable，然后读取 SSTable</li>
</ul>
<h3 id="读取的优化">读取的优化</h3>
<ul>
<li>通过 BloomFilter 优化不存在的数据的判断</li>
<li>SSTable 分区</li>
<li>压缩</li>
</ul>
<h2 id="lsmt-的问题">LSMT 的问题</h2>
<h3 id="读放大">读放大</h3>
<p>一次 key 的读取需要由新到旧依次读取，涉及到不止一次IO，在范围查询的时候尤其明显。</p>
<h3 id="写放大">写放大</h3>
<p>后台合并（compaction）导致一个文件可能需要被写入多次。</p>
<h3 id="空间放大">空间放大</h3>
<p>Append-only 导致过期数据一致存在，直到被清理</p>
<h2 id="总结">总结</h2>
<ul>
<li>写放大：尽管 LSM Tree 通过顺序 IO 提供了更大的写入吞吐，但是写入放大的问题会争抢正常写入的磁盘带宽，从而降低性能和磁盘的使用寿命。</li>
<li>合并：后台的合并操作导致 write stall</li>
<li>新硬件：Remote compaction，Compaction offloading，AEP</li>
</ul>
<p>索引存储</p>
<ul>
<li>索引不存储
<ul>
<li>buntdb：每次重启重建</li>
</ul>
</li>
<li>索引存储
<ul>
<li>分离存储
<ul>
<li>Bitcask</li>
<li>MySQL MyISAM</li>
</ul>
</li>
<li>一起存储
<ul>
<li>BoltDB</li>
<li>MySQL Innodb</li>
<li>LevelDB (SStable)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="reference">Reference</h1>
<ul>
<li><a href="https://www.youtube.com/watch?v=adamqSuHHck&amp;ab_channel=TalkGo">理论结合实践详解 lsm 树存储引擎（bitcask、moss、leveldb 等）</a></li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>使用 GitHub Issue 作为 Hugo 的评论系统</title>
			<link>https://huanglei.rocks/posts/hugo-comment-with-github-issues/</link>
			<pubDate>Thu, 10 Feb 2022 15:07:10 +0800</pubDate>
			
			<guid>https://huanglei.rocks/posts/hugo-comment-with-github-issues/</guid>
			<description>安装 Octomments 按照 Octomments 的介绍，将 Octomments 安装到您的 GitHub 账户，确保它拥有访问您的目标 repo 的 issue 的权限。 配置 GitHub issue 在配置文件中增加配置项： comment.owner：I</description>
			<content type="html"><![CDATA[<h1 id="安装-octomments">安装 Octomments</h1>
<p>按照 <a href="https://ocs.vercel.app/">Octomments</a> 的介绍，将 Octomments 安装到您的 GitHub 账户，确保它拥有访问您的目标 repo 的 issue 的权限。</p>
<h1 id="配置-github-issue">配置 GitHub issue</h1>
<p>在配置文件中增加配置项：</p>
<ul>
<li><code>comment.owner</code>：Issue repo 的拥有者</li>
<li><code>comment.repo</code>：Issue repo 的名字</li>
</ul>
<h1 id="配置-comment-组件">配置 Comment 组件</h1>
<p>在您的博客站点根目录下的<code>layouts/partials/comments.html</code> 模板中增加：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-html" data-lang="html"><span class="line"><span class="cl">{{ if .Params.issueNumber -}}
</span></span><span class="line"><span class="cl"><span class="p">&lt;</span><span class="nt">link</span> <span class="na">href</span><span class="o">=</span><span class="s">&#34;https://unpkg.com/octomments/build/ocs-ui.min.css&#34;</span> <span class="na">rel</span><span class="o">=</span><span class="s">&#34;stylesheet&#34;</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;</span><span class="nt">div</span> <span class="na">id</span><span class="o">=</span><span class="s">&#34;comments&#34;</span><span class="p">&gt;&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;</span><span class="nt">script</span> <span class="na">src</span><span class="o">=</span><span class="s">&#34;https://unpkg.com/octomments/build/ocs.min.js&#34;</span><span class="p">&gt;&lt;/</span><span class="nt">script</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">&lt;</span><span class="nt">script</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="nx">Octomments</span><span class="p">({</span>
</span></span><span class="line"><span class="cl">    <span class="nx">github</span><span class="o">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">owner</span><span class="o">:</span> <span class="s1">&#39;{{ $.Site.Params.comment.owner }}&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="nx">repo</span><span class="o">:</span> <span class="s1">&#39;{{ $.Site.Params.comment.repo }}&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="p">},</span>
</span></span><span class="line"><span class="cl">    <span class="nx">issueNumber</span><span class="o">:</span> <span class="p">{{</span> <span class="p">.</span><span class="nx">Params</span><span class="p">.</span><span class="nx">issueNumber</span> <span class="p">}},</span>
</span></span><span class="line"><span class="cl">    <span class="nx">renderer</span><span class="o">:</span> <span class="p">[</span><span class="nx">OctommentsRenderer</span><span class="p">,</span> <span class="s1">&#39;#comments&#39;</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">  <span class="p">}).</span><span class="nx">init</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;/</span><span class="nt">script</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">{{ end }}
</span></span></code></pre></div><h1 id="配置需要评论的文章">配置需要评论的文章</h1>
<p>在文章的 metadata 章节加入创建的 issue 的 issue number，如本文的 metadata：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="cl"><span class="nn">---</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">title</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;使用 GitHub Issue 作为 Hugo 的评论系统&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">date</span><span class="p">:</span><span class="w"> </span><span class="ld">2022-02-10T15:07:10</span><span class="m">+08</span><span class="p">:</span><span class="m">00</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">draft</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">toc</span><span class="p">:</span><span class="w"> </span><span class="kc">false</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">issueNumber</span><span class="p">:</span><span class="w"> </span><span class="m">3</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">images</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">tags</span><span class="p">:</span><span class="w"> 
</span></span></span><span class="line"><span class="cl"><span class="w">  </span>- <span class="l">Hugo</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span>- <span class="l">Github</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nn">---</span><span class="w">
</span></span></span></code></pre></div><p>这样本文的末尾就会出现一个评论栏啦，所有对本文的评论都会同步到 GitHub 的 issue 中。</p>
]]></content>
		</item>
		
		<item>
			<title>Rust 对象安全详解</title>
			<link>https://huanglei.rocks/posts/object-safety/</link>
			<pubDate>Thu, 09 Dec 2021 21:57:33 +0800</pubDate>
			
			<guid>https://huanglei.rocks/posts/object-safety/</guid>
			<description>Rust 的 RFC 上只给出了 object-safety 的定义，但是没有解释为何在满足这些条件的时候 trait 是 object safe 的，以及为啥需要 object safety，这反而是初学者最为困惑的点。 为什么需要</description>
			<content type="html"><![CDATA[<p>Rust 的 <a href="https://rust-lang.github.io/rfcs/0255-object-safety.html">RFC</a> 上只给出了 object-safety 的定义，但是没有解释为何在满足这些条件的时候 trait 是 object safe 的，以及为啥需要 object safety，这反而是初学者最为困惑的点。</p>
<h1 id="为什么需要-object-safety">为什么需要 object safety？</h1>
<p>Rust 通过 trait object 提供了类型擦除、动态分派的能力，但是这个能力是有限制的，不是所有的 trait 都能自动生成实现。
<strong>Trait object 本质上是对某个 trait 的自动默认实现，包括一个数据区和一个方法表。<u>Object-safety 就是为了保证 Rust 编译器能够为某个 trait 生成合法自动实现。</u></strong></p>
<p><img src="https://gw.alipayobjects.com/zos/antfincdn/QAgzwRCoT/1644416416.png" alt="trait-object.png"></p>
<div style="text-align: center;">
<i>
 Trait object 的内存布局 
</i>
</div>
<blockquote>
<p><a href="https://huonw.github.io/blog/2015/05/where-self-meets-sized-revisiting-object-safety/">Where Self Meets Sized: Revisiting Object Safety</a></p>
</blockquote>
<p>首先是关于 trait 的 object safety，一个 trait 是对象安全的，当且仅当它<strong>满足以下<u>所有</u>条件</strong>：</p>
<ul>
<li>trait 的类型不能限定为 <code>Self: Sized</code><sup>1️⃣</sup>；</li>
<li>trait 中所定义的所有方法都是 object-safe 的<sup>2️⃣</sup>；</li>
</ul>
<p>接下来是关于方法的 object safety：一个方法是对象安全的，当且仅当这个方法<strong>满足下面<u>任意一个</u>特性</strong>：</p>
<ul>
<li>方法 receiver 的类型限定是 <code>Self: Sized</code><sup>3️⃣ </sup>；或者</li>
<li>满足以下所有条件：
<ul>
<li>方法不能有泛型参数<sup>4️⃣</sup>；且</li>
<li>receiver 类型必须是 Self 或者可以解引用为 Self 的引用类型<sup>5️⃣ </sup>。目前只包括<code>self</code>/ <code>&amp;self</code> / <code>&amp;mut self</code>/ <code>self: Box&lt;Self&gt;</code>。以后可能也会扩展到 <code>Rc&lt;Self&gt;</code>等等。</li>
<li><code>Self</code>类型只能用作 receiver <sup>6️⃣ </sup></li>
</ul>
</li>
</ul>
<p>1️⃣   也就是说，如下的 trait 是不能用作 trait object 的。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">trait</span><span class="w"> </span><span class="n">Test</span>: <span class="nb">Sized</span> <span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">	</span><span class="k">fn</span> <span class="nf">some_method</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>为什么trait 的方法的 receiver 不能限定为 <code>Self: Sized</code>？因为 trait object 本身是动态分派的，编译期无法确定 trait object 的大小。如果这个时候 trait object 的方法又要求 Self 大小可确定，那就互相矛盾了。
需要注意的是，trait object 自身的大小是可确定的，因为其只包括指向数据的指针和指向 vtable 的指针而已。</p>
<p>2️⃣   要求 trait 所有的方法都是对象安全的也是为了确保动态分派的时候能够正确从 vtable 中找到方法进行调用。</p>
<p>3️⃣   由于 trait object 自身是 Unsized，如果方法限定了<code>Self: Sized</code>，那么一定无法通过 trait object 去调用。也就不会导致动态分派的 object safety 问题，因此一个限定了 <code>Self: Sized</code>的 trait 方法也被认为是 object-safe 的。</p>
<blockquote>
<ul>
<li><a href="https://stackoverflow.com/questions/42620022/why-does-a-generic-method-inside-a-trait-require-trait-object-to-be-sized">Why does a generic method inside a trait require trait object to be sized? - Stack Overflow</a></li>
<li><a href="https://github.com/rust-lang/rust/issues/22031">A method marked where Self: Sized on a trait should not be considered during object safety checks #22031</a></li>
</ul>
</blockquote>
<p>4️⃣   如果方法不限定 <code>Self: Sized</code> ，就意味着那么这个方法首先不能有泛型参数。如果有泛型参数，那么 vtable 中的方法列表大小是难以确定的。当然如果非要做，在编译期，rust 编译器可以拿到 trait 的所有具体实现，然后为每一个具体实现在 vtable 生成一个特化的方法项。但是首先这会大大降低编译速度，其次也会引入极大的复杂性。因此 Rust 的 trait object 直接禁止了这种使用场景。</p>
<blockquote>
<p><a href="https://stackoverflow.com/questions/67767207/why-are-trait-methods-with-generic-type-parameters-object-unsafe">Why are trait methods with generic type parameters object-unsafe?</a></p>
</blockquote>
<p>5️⃣   如果方法没有 receiver，那么使用 trait object 毫无意义，因为这个方法的调用根本不需要 trait object 里面的 data 指针。</p>
<p>6️⃣   假设 trait 定义了这么一个方法：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">trait</span><span class="w"> </span><span class="n">Test</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">	</span><span class="k">fn</span> <span class="nf">duplicate</span><span class="p">(</span><span class="bp">self</span>: <span class="nc">Self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>那么这个 trait 的 duplicate 方法要求返回的类型和方法 receiver 的类型是一样的。如果 Trait 是静态分派，那么在编译器就可以确定所有可能的方法签名。比如结构体 A、B 实现了 Test trait，那么 duplicate 方法所有可能的签名是：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">fn</span> <span class="nf">duplicate</span><span class="p">(</span><span class="bp">self</span>: <span class="nc">A</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">A</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">fn</span> <span class="nf">duplicate</span><span class="p">(</span><span class="bp">self</span>: <span class="nc">B</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">B</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><p>而在动态分派下，从一个 trait object 发起方法的调用，也就无法在编译期约束不同位置的 Self 类型都是一致的，完全有可能出现下面的情况：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">fn</span> <span class="nf">duplicate</span><span class="p">(</span><span class="bp">self</span>: <span class="nc">B</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">A</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><p>显然这不是对 <code>Test</code> 这个 trait 的一个合法实现。</p>
<ul>
<li><a href="https://rust-lang.github.io/rfcs/0255-object-safety.html">https://rust-lang.github.io/rfcs/0255-object-safety.html</a></li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>Paxos Made Simple 笔记 (WIP)</title>
			<link>https://huanglei.rocks/posts/notes-on-paxos-made-simple/</link>
			<pubDate>Mon, 14 Jun 2021 11:24:18 +0800</pubDate>
			
			<guid>https://huanglei.rocks/posts/notes-on-paxos-made-simple/</guid>
			<description>关于 P2c P2c 是 P2b 的充分不必要条件，why？ P2b: If a proposal with value v is chosen, then every higher-numbered proposal issued by any proposer has value v. P2c: For any v and n, if a proposal with value v and number n is issued, then there is a set S consisting of a majority of acceptors such that</description>
			<content type="html"><![CDATA[<h1 id="关于-p2c">关于 P2c</h1>
<p>P2c 是 P2b 的充分不必要条件，why？</p>
<blockquote>
<ul>
<li>P2b: If a proposal with value v is chosen, then every higher-numbered proposal issued by any proposer has value <code>v</code>.</li>
<li>P2c: For any <code>v</code> and <code>n</code>, if a proposal with value <code>v</code> and number <code>n</code> is issued, then there is a set S consisting of a majority of acceptors such that either
<ul>
<li>(a) no acceptor in S has accepted any proposal numbered less than <code>n</code>, or</li>
<li>(b) <code>v</code> is the value of the highest-numbered proposal among all proposals numbered less than <code>n</code> accepted by the acceptors in S.</li>
</ul>
</li>
</ul>
</blockquote>
<p>已知 proposal:<code>(m,v)</code>被选中，要满足任意 proposer 提出序号 n （n &gt; m）的 proposal 的值都是 <code>v</code>，那么只要满足条件：<u> $ \forall i\in [m,\ n-1]$ ，有 proposal <code>i</code> 的值是 <code>v</code> 1</u>，那么根据数学归纳法，proposal <code>n</code>的值也必然是 <code>v</code>。</p>
<p>1: 是附加假设，我们需要根据这个附加假设去约束 proposer 的行为，从而使得 P2b 能够被满足。下面就需要解释这个附加假设对 proposer 的行为做出了什么样的约束。</p>
<p>由于 <code>(m,v)</code>已经被选中了，那就意味着存在一个 acceptor 的集合 C 满足任意 C 中的 acceptor 都 accept 了<code>(m,v)</code>，再加上我们需要让附加假设（满足 $i\in [m,\ n-1]$ ，有 proposal <code>i</code> 的值是 <code>v</code>）成立，
这就意味着所谓的 C-condition 2 ，对于 accept 了 <code>(m,v)</code> 的 acceptor 集合 C，满足：</p>
<ul>
<li>(1)  C 中的所有 acceptor 都 accept 了 $[m,\ n-1]$ 中的一个 proposal（因为至少有<code>m</code>已经被 C 中的所有 acceptor 给 accept 了）</li>
<li>(2) $[m,\ n-1]$ 中所有的被任意 acceptor 所 accept 的 proposal 的值都是 <code>v</code>（注意，这里约束的对象从 proposer 变成了 acceptor，实际上 narrow down 了，因为是非拜占庭问题，所有被 acceptor 所 accept 的值都需要 proposer 提出）。</li>
</ul>
<p>那么只要 proposer 满足 P2c，就能满足所谓的 C-condition，从而实现 P2c -&gt; C-condidtion -&gt; 附加假设 1-&gt; P2b 的证明路径。</p>
<blockquote>
<p>为什么 P2c 可以保证 C-condidition？
P2c 约束了 proposer 每次提案之前先要知道 majority 的情况，由于<code>(m,v)</code>已经 chosen，因此符合 P2c 的 proposer 在提出 m+1 的时候，提案的值必然是 m（highest accepted proposal）的值 v，m+2、m+3 直到 n-1 都是这样，从而可以保证 C-condition 的 (2)，</p>
</blockquote>
<p>因此 P2b 到 P2c 实际上是让约束逐步可实现化的 narrow down，因为让 proposer 去感知 acceptor 的状态是更容易实现的。</p>
<blockquote>
<p>Learning about proposals already accepted is easy enough; predicting future acceptances is hard. Instead of trying to predict the future, the proposer controls it by extracting a promise that there won’t be any such acceptances.</p>
</blockquote>
]]></content>
		</item>
		
		<item>
			<title>现代 Java 捉虫指南</title>
			<link>https://huanglei.rocks/posts/java-debug-manual/</link>
			<pubDate>Fri, 12 Feb 2021 22:01:27 +0800</pubDate>
			
			<guid>https://huanglei.rocks/posts/java-debug-manual/</guid>
			<description>gnu.hl@antgroup.com 2020-12-01 本文是作者 2021 年在蚂蚁内部分享时的 slides 经过脱敏之后的版本。 当我们排查问题的时候，我们关注什么？ 横向来看: context/critical path/caller/callee (tracing) statistics/metrics (profiling) 纵向来看: application runtime kernel Arthas Arthas 是基于</description>
			<content type="html"><![CDATA[<p><img src="https://gw.alipayobjects.com/zos/antfincdn/Se%26jyp0zs1/fe9fd884-3cb2-4cf7-b060-cd8d704cb03e.png#crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;id=HK8X9&amp;originHeight=1634&amp;originWidth=2419&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p>
<div style="text-align: center;">
<i>
 <a href="mailto:gnu.hl@antgroup.com">gnu.hl@antgroup.com</a>  
</i>
</div>
<div style="text-align: center;">
<i>
<p><strong>2020-12-01</strong></p>
</i>
</div>
<hr>
<blockquote>
<p>本文是作者 2021 年在蚂蚁内部分享时的 slides 经过脱敏之后的版本。</p>
</blockquote>
<h2 id="当我们排查问题的时候我们关注什么">当我们排查问题的时候，我们关注什么？</h2>
<p>横向来看:</p>
<ul>
<li>context/critical path/caller/callee (tracing)</li>
<li>statistics/metrics (profiling)</li>
</ul>
<p>纵向来看:</p>
<ul>
<li>application</li>
<li>runtime</li>
<li>kernel</li>
</ul>
<hr>
<h2 id="arthas">Arthas</h2>
<blockquote>
<p>Arthas 是基于字节码增强的调试工具.</p>
</blockquote>
<p>功能:</p>
<ul>
<li>观察方法的入参/返回值/异常等数据</li>
<li>观察内存对象的值</li>
<li>跟踪方法的耗时和调用栈</li>
<li>查看类加载来源/热更新类定义</li>
</ul>
<h3 id="安装">安装</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">curl -L http://start.alibaba-inc.com/install.sh <span class="p">|</span> sh
</span></span></code></pre></div><hr>
<h3 id="arthas-使用方法">Arthas 使用方法</h3>
<ul>
<li>观察方法入参、返回值、异常</li>
</ul>
<pre tabindex="0"><code>watch &lt;class_fqcn&gt; &lt;method_name&gt; &#34;{params,returnObj,throwExp}&#34; [condition] [-f] [-b] [-xN]
</code></pre><ul>
<li>拦截指定线程执行的方法</li>
</ul>
<pre tabindex="0"><code>watch &lt;class_fqcn&gt; &lt;method_name&gt; &#34;{params,returnObj,throwExp}&#34; \
  &#34;@java.lang.Thread@currentThread().getName()==&#39;&lt;thread_name&gt;&#39;&#34; [-f] [-b] [-xN]
</code></pre><ul>
<li>在观察入参同时打印方法栈</li>
</ul>
<pre tabindex="0"><code>watch &lt;class_fqcn&gt; &lt;method_name&gt; &#34;{params,returnObj,throwExp, \
@java.lang.Thread@currentThread().getStackTrace()}&#34; [condition] [-f] [-b] [-xN]
</code></pre><hr>
<h3 id="arthas-使用方法cont">Arthas 使用方法(cont.)</h3>
<ul>
<li>耗时较长的方法</li>
</ul>
<pre tabindex="0"><code>watch &lt;class_fqcn&gt; &lt;method_name&gt; &#34;{params,returnObj,throwExp, @java.lang.Thread@currentThread().getStackTrace()}&#34; \
&#39;#cost&gt;100 [&amp;&amp; other_cond]&#39; [-f] [-b] [-xN]
</code></pre><ul>
<li>classloading 问题</li>
</ul>
<pre tabindex="0"><code>sc -d &#39;&lt;class_name&gt;&#39;
</code></pre><ul>
<li>构造对象</li>
</ul>
<pre tabindex="0"><code>watch com.alipay.antq.broker.processor.SendMessageProcessor sendMessage \
&#34;{new java.lang.String(params[1].body)}&#34; -x2 -n10
</code></pre><hr>
<h3 id="arthas-使用方法cont-1">Arthas 使用方法(cont.)</h3>
<ul>
<li>Projection &amp; filtering</li>
</ul>
<pre tabindex="0"><code>watch com.alipay.antqnamesrv.core.service.broker.BrokerFileService getBrokerFiles \
    &#34;{returnObj[&#39;FILE_CLUSTER&#39;][&#39;antq-eu95-3.gz00b.stable.alipay.net&#39;]\
    .topicQueues.values().{ #this.{? #this.queueId==32 } }.{? #this.size()!=0 }}&#34; -x3
</code></pre><ul>
<li>观察方法执行路径</li>
</ul>
<pre tabindex="0"><code>trace [--skipJDKMethod true|false] &lt;class_fqcn&gt; &lt;method_name&gt;
</code></pre><blockquote>
<p>N/A</p>
</blockquote>
<hr>
<h3 id="arthas-使用方法cont-2">Arthas 使用方法(cont.)</h3>
<ul>
<li>制作火焰图</li>
</ul>
<pre tabindex="0"><code># list all events
profiler list
# profile object allocation
profiler start --event alloc -d 10
# profile lock acquire
profiler start --event lock -d 10
</code></pre><ul>
<li>热更新代码</li>
</ul>
<pre tabindex="0"><code>mc/redefine
</code></pre><p>N/A</p>
<hr>
<h3 id="arthas-的缺陷">Arthas 的缺陷</h3>
<ul>
<li>启动期观测 -&gt; <code>jdb</code> / <a href="https://github.com/btraceio/btrace">btrace</a></li>
<li>测量引入 overhead</li>
<li>注意内存问题</li>
</ul>
<hr>
<h2 id="eclipse-mat--zprofiler">Eclipse MAT / zprofiler</h2>
<ul>
<li><a href="https://lark-assets-prod-aliyun.oss-accelerate.aliyuncs.com/lark/0/2020/png/122844/1595069971931-7bb33b65-cb9e-41a0-b1b4-8547b2c1708b.png?OSSAccessKeyId=LTAI4GGhPJmQ4HWCmhDAn4F5&amp;Expires=1607186074&amp;Signature=LF4bn%2FxILpoIgYCGtFBWyEjDIXE%3D&amp;response-content-disposition=inline">OQL</a>
<code>select * from io.netty.channel.AbstractChannelhandlerContext$11</code></li>
</ul>
<h3 id="native-memory-issues">Native memory issues</h3>
<p>RSS = xmx +  MaxDirectMemory + N * xss [ + gc + code cache + metaspace ]</p>
<ul>
<li>case1) DirectByteBuffer 未释放-&gt;通过观察堆内的DirectMemory</li>
<li>case2) <code>[G]ZIPInput[/Output]Stream</code>/<code>De[/In]flater</code> <a href="https://www.evanjones.ca/java-native-leak-bug.html">native memory leak</a></li>
<li>case3) Netty&lt;= 4.0.24 <a href="https://github.com/netty/netty/pull/3844">epoll native memory leak</a></li>
<li>case4) <a href="https://bugs.java.com/bugdatabase/view_bug.do?bug_id=JDK-8164293">JDK-8164293:HotSpot leaking memory</a> (fixed <a href="/8u152">@8u152) </a> )</li>
</ul>
<hr>
<h2 id="sa-jdi--clhsdb">sa-jdi / clhsdb</h2>
<blockquote>
<p>Off-process vs. in-process instrumentation</p>
</blockquote>
<ul>
<li>sa: serviceability agent</li>
<li>clhsdb: command-line hotspot debugger</li>
<li>sa-jdi 提供了获取 JVM 内部数据结构的编程接口</li>
<li>sa-jdi 不仅可以 attach 活着的进程, 也可以分析 coredump</li>
<li><code>jstack</code>/<code>jstat</code>等工具均提供了基于 attach api(tools.jar) 和 sa-jdi(sa-jdi.jar)的实现</li>
<li><a href="https://www.iteye.com/blog/rednaxelafx-1847971">借HSDB来探索HotSpot VM的运行时数据</a></li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">ls <span class="nv">$JAVA_HOME</span>/lib
</span></span><span class="line"><span class="cl">java -cp <span class="nv">$JAVA_HOME</span>/lib/sa-jdi.jar sun.jvm.hotspot.CLHSDB
</span></span></code></pre></div><hr>
<h2 id="sa-jdi--clhsdbcont">sa-jdi / clhsdb(cont.)</h2>
<h5 id="使用-sa-jdi-分析反射生成的类">使用 sa-jdi 分析反射生成的类</h5>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">sun.jvm.hotspot.oops.InstanceKlass</span><span class="o">;</span>
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">sun.jvm.hotspot.tools.jcore.ClassFilter</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MethodAccessorFilter</span> <span class="kd">implements</span> <span class="n">ClassFilter</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="nd">@Override</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">canInclude</span><span class="o">(</span><span class="n">InstanceKlass</span> <span class="n">instanceKlass</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">instanceKlass</span><span class="o">.</span><span class="na">getName</span><span class="o">().</span><span class="na">asString</span><span class="o">().</span><span class="na">startsWith</span><span class="o">(</span><span class="s">&#34;sun/reflect/Generated&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">java -classpath <span class="s2">&#34;.:</span><span class="nv">$JAVA_HOME</span><span class="s2">/lib/sa-jdi.jar&#34;</span> <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>-Dsun.jvm.hotspot.tools.jcore.filter<span class="o">=</span>MethodAccessorFilter sun.jvm.hotspot.tools.jcore.ClassDump &lt;pid&gt;
</span></span></code></pre></div><blockquote>
<p>SA-JDI is deprecated since Java9 &ndash; <a href="https://bugs.openjdk.java.net/browse/JDK-8158050">JDK-8158050</a></p>
</blockquote>
<hr>
<h2 id="jfr">JFR</h2>
<ul>
<li>域内要求 JVM 版本 <code>^ajdk-8_5_10_fp2-b9</code></li>
<li><code>-XX:+EnableJFR -XX:+FlightRecorder -XX:FlightRecorderOptions=&lt;opt&gt;=&lt;val&gt; -XX:StartFlightRecording=&lt;opt&gt;=&lt;val&gt;</code></li>
<li>可分析的事件类型:
<ul>
<li>Lock contention</li>
<li>Memory allocation</li>
<li>IO performance (Network/File)</li>
<li>Code execution performance</li>
<li>Garbage Collector</li>
<li>JIT performance</li>
</ul>
</li>
</ul>
<hr>
<h2 id="jfr-cont">JFR (cont.)</h2>
<p>使用步骤</p>
<ul>
<li>启动进程时增加开启 JFR 的参数</li>
<li>开始 JFR 记录 <code>jcmd &lt;pid&gt; JFR.start settings=profile name=&lt;record_name&gt;</code></li>
<li>dumpJFR 记录 <code>jcmd &lt;pid&gt; JFR.dump filename=jfr.output name=&lt;record_name&gt;</code></li>
<li>使用 <a href="https://www.oracle.com/java/technologies/jdk-mission-control.html">JDK Mission Control</a> 分析 JFR dump</li>
</ul>
<hr>
<h2 id="jfr-cont-1">JFR (cont.)</h2>
<p>参考资料</p>
<ul>
<li><a href="http://hirt.se/blog/">Continuous Production Profiling and Diagnostics</a></li>
<li><a href="https://www.javacodegeeks.com/2015/03/oracle-java-mission-control-the-ultimate-guide.html">Oracle Java Mission Control: The Ultimate Guide</a></li>
</ul>
<hr>
<h2 id="interesting-cases">Interesting Cases</h2>
<ul>
<li>N/A</li>
<li>N/A</li>
<li>N/A</li>
</ul>
<hr>
<h2 id="one-more-thing">One more thing</h2>
<table>
<thead>
<tr>
<th>Component</th>
<th>Tool</th>
</tr>
</thead>
<tbody>
<tr>
<td>Application on runtime(Java/Node/Ruby/PHP)</td>
<td>Runtime debugger,eBPF</td>
</tr>
<tr>
<td>Application (native code)</td>
<td>System debugger,eBPF</td>
</tr>
<tr>
<td>System libraries: /lib/*</td>
<td>ltrace(1),eBPF</td>
</tr>
<tr>
<td>System call interface</td>
<td>strace(1), perf(1),eBPF</td>
</tr>
<tr>
<td>Network Traffic</td>
<td>tcpdump(8),eBPF</td>
</tr>
<tr>
<td>Kernel: Scheduler, file systems, TCP, IP, etc</td>
<td>ftrace(1), perf(1),eBPF</td>
</tr>
<tr>
<td>Hardware: CPU internals, devicec</td>
<td>perf, sar, eBPF</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="perf">Perf</h2>
<ul>
<li>Why is the kernel on-CPU so much? What code-paths?</li>
<li>Which code-paths are causing CPU level 2 cache misses?</li>
<li>Are the CPUs stalled on memory I/O?</li>
<li>Which code-paths are allocating memory, and how much?</li>
<li>What is triggering TCP retransmits?</li>
<li>Is a certain kernel function being called, and how often?</li>
<li>What reasons are threads leaving the CPU?</li>
</ul>
<p>&ndash; Brendan Greg</p>
<hr>
<h2 id="perf-cont">Perf (cont.)</h2>
<p><code>perf_event</code>:</p>
<ul>
<li>Software events</li>
<li>Hardware events</li>
<li>Kernel static tracepoint events</li>
<li>USDT</li>
</ul>
<p><img src="https://intranetproxy.alipay.com/skylark/lark/0/2020/png/122844/1606655883925-873a4d92-9d1b-4d7d-8e24-31cd567ebd1f.png?x-oss-process=image%2Fresize%2Cw_1412#crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;id=oFLoJ&amp;originHeight=988&amp;originWidth=1412&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p>
<p><code>sudo perf list</code> to list all available events.</p>
<hr>
<pre tabindex="0"><code># sudo perf record -e block:block_rq_issue -e block:block_rq_complete -a sleep 10
[ perf record: Woken up 1 times to write data ]
[ perf record: Captured and wrote 0.428 MB perf.data (~18687 samples) ]
# sudo perf script
        run 30339 [000] 2083345.722767: block:block_rq_complete: 202,1 W () 12984648 + 8 [0]
        run 30339 [000] 2083345.722857: block:block_rq_complete: 202,1 W () 12986336 + 8 [0]
        run 30339 [000] 2083345.723180: block:block_rq_complete: 202,1 W () 12986528 + 8 [0]
    swapper     0 [000] 2083345.723489: block:block_rq_complete: 202,1 W () 12986496 + 8 [0]
    swapper     0 [000] 2083346.745840: block:block_rq_complete: 202,1 WS () 1052984 + 144 [0]
  supervise 30342 [000] 2083346.746571: block:block_rq_complete: 202,1 WS () 1053128 + 8 [0]
  supervise 30342 [000] 2083346.746663: block:block_rq_complete: 202,1 W () 12986608 + 8 [0]
        run 30342 [000] 2083346.747003: block:block_rq_complete: 202,1 W () 12986832 + 8 [0]

                                                                            
              /---------------------------------------- #1  supervise: on-CPU cmd                                                             
             /       /--------------------------------- #2  30342: on-CPU cmd tid                                                       
            /       /     /---------------------------- #3  [000]: CPU running cmd                                                 
           /       /     /          /------------------ #4  2083346.746571: reltime                                        
          /       /     /          /                /-- #5  block:block_rq_complete: tracepoint  
         /       /     /          /                /                  /------------- #6  202,1 : storage major,minor number, ref lsblk
        /       /     /          /                /                  /    /--------- #7  IO type: W-Write,R-Read,A-ReadAheader,O-Sync,WS-Sync Write   
       /       /     /          /                /                  /    /  /------- #8  (): Block command details
      /       /     /          /                /                  /    /  /     /-- #9  12986336: storage device offset
     /       /     /          /                /                  /    /  /     /     /---- #10 +8: size of IO (in sectors)
    /       /     /          /                /                  /    /  /     /     /  /-- #11 [0]: if errors happened
supervise 30342 [000] 2083346.746571: block:block_rq_complete: 202,1 WS () 1053128 + 8 [0]
# how can I get this format?  cat /sys/kernel/debug/tracing/events/{event_cat}/{event_name}/format

perf script | awk &#39;{ gsub(/:/, &#34;&#34;) } $5 ~ /issue/ { ts[$6, $10] = $4 }
    $5 ~ /complete/ { if (l = ts[$6, $9]) { printf &#34;%.f %.f\n&#34;, $4 * 1000000,
    ($4 - l) * 1000000; ts[$6, $10] = 0 } }&#39;
</code></pre><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">sudo yum install -y kernel-devels
</span></span><span class="line"><span class="cl">sudo yum install -y kernel-headers
</span></span><span class="line"><span class="cl">sudo mount -t debugfs debugfs /sys/kernel/debug
</span></span></code></pre></div><hr>
<h2 id="using-perf-trace-java-io-issues">Using perf trace Java IO issues</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">sudo perf record -e block:block_rq_issue  -a -g  -p &lt;pid&gt; sleep <span class="m">10</span>
</span></span><span class="line"><span class="cl">sudo perf report -G <span class="c1"># No java stack info ?</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">sudo yum install -y gcc-c++ cmake
</span></span><span class="line"><span class="cl">git clone https://github.com/jvm-profiling-tools/perf-map-agent
</span></span><span class="line"><span class="cl"><span class="nb">cd</span> perf-map-agent <span class="o">&amp;&amp;</span> cmake . <span class="o">&amp;&amp;</span> make -j8
</span></span><span class="line"><span class="cl">./bin/create-java-perf-map.sh &lt;pid&gt;
</span></span><span class="line"><span class="cl"><span class="nb">cd</span> -
</span></span><span class="line"><span class="cl">perf report -G <span class="c1"># gotcha!</span>
</span></span></code></pre></div><hr>
<h2 id="flame-graph">Flame Graph</h2>
<pre tabindex="0"><code>git clone https://github.com/brendangregg/FlameGraph
sudo perf script | \
    &lt;path-to&gt;/stackcollapse-perf.pl | \
    &lt;path-to&gt;/flamegraph.pl &gt; perf-kernel.svg
</code></pre><h2 id="reference">Reference</h2>
<ul>
<li><a href="http://www.brendangregg.com/perf.html#OneLiners">perf one-liners</a></li>
<li><a href="http://www.brendangregg.com/blog/2015-02-26/linux-perf-off-cpu-flame-graph.html">Off-CPU Analysis</a></li>
</ul>
<hr>
<h2 id="内存增长的另外一种思路">内存增长的另外一种思路</h2>
<ul>
<li>通过<code>LD_PRELOAD</code>替换分配器为 jemalloc</li>
<li>开启 jemalloc 的泄漏分析</li>
<li>启动进程, 找到泄漏的 native 栈</li>
<li>用 <code>perf record -e &lt;tp&gt; -ag</code> 抓取分配的事件</li>
<li><code>create-java-perf-map.sh</code> 生成符号表</li>
<li><code>perf report/script</code> 查看访问线程</li>
</ul>
<hr>
<h2 id="ebpfxdp">eBPF/XDP</h2>
<blockquote>
<p>eBPF does to Linux what JavaScript does to HTML. &ndash; Brendan Gregg</p>
</blockquote>
<p><img src="https://gw.alipayobjects.com/zos/antfincdn/px8%24TS%2457N/5324708e-a7f5-44d7-963b-a569fd0b6d08.png#crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;id=RJ0w2&amp;originHeight=818&amp;originWidth=1132&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p>
<hr>
<h2 id="ebpf-probes">eBPF probes</h2>
<ul>
<li>Probes (Dynamic, Using <code>trap</code>)
<ul>
<li><a href="https://www.kernel.org/doc/Documentation/kprobes.txt">k{,ret}probes</a></li>
<li><a href="https://lwn.net/Articles/499190/">u{,ret}probes</a></li>
</ul>
</li>
<li>Tracepoints (Static, predefined)
<ul>
<li><a href="https://static.lwn.net/kerneldoc/trace/tracepoints.html">Kernel tracepoints</a>
<ul>
<li><code>cat /sys/kernel/debug/tracing/available_events</code></li>
</ul>
</li>
<li><a href="https://lwn.net/Articles/753601/">USDT</a>
<ul>
<li><code>readelf -n X.so | grep -A4 NT_STAPSDT</code></li>
<li><code>tplist.py -p &lt;running_process&gt;</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="ebpf-vs-perf">eBPF vs. Perf</h2>
<p><img src="https://gw.alipayobjects.com/zos/antfincdn/d9OtRCINlq/4f7646df-bab8-4fe7-8bd8-5e7ba7005996.png#crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;id=swEsD&amp;originHeight=964&amp;originWidth=1424&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p>
<hr>
<h2 id="ebpf-hello-world">eBPF Hello world</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="ch">#!/usr/bin/python</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">bcc</span> <span class="kn">import</span> <span class="n">BPF</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">prog</span> <span class="o">=</span> <span class="s2">&#34;&#34;&#34;
</span></span></span><span class="line"><span class="cl"><span class="s2">int hello(void *ctx) {
</span></span></span><span class="line"><span class="cl"><span class="s2">    bpf_trace_printk(&#34;Hello world</span><span class="se">\\</span><span class="s2">n&#34;);
</span></span></span><span class="line"><span class="cl"><span class="s2">    return 0;
</span></span></span><span class="line"><span class="cl"><span class="s2">}
</span></span></span><span class="line"><span class="cl"><span class="s2">&#34;&#34;&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">b</span> <span class="o">=</span> <span class="n">BPF</span><span class="p">(</span><span class="n">text</span><span class="o">=</span><span class="n">prog</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">#print(b.get_syscall_fnname(&#34;clone&#34;)) # platform-dependent syscall kprobe name</span>
</span></span><span class="line"><span class="cl"><span class="n">b</span><span class="o">.</span><span class="n">attach_kprobe</span><span class="p">(</span><span class="n">event</span><span class="o">=</span><span class="s2">&#34;__x64_sys_clone&#34;</span><span class="p">,</span> <span class="n">fn_name</span><span class="o">=</span><span class="s2">&#34;hello&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">#        ^~~~~~ this is a kprobe </span>
</span></span><span class="line"><span class="cl"><span class="n">b</span><span class="o">.</span><span class="n">trace_print</span><span class="p">()</span>
</span></span></code></pre></div><hr>
<h2 id="bcc-bpf-compiler-collection">BCC (BPF Compiler Collection)</h2>
<blockquote>
<p>&mdash;eBPF made simple</p>
</blockquote>
<p><img src="https://gw.alipayobjects.com/zos/antfincdn/ZknkdEV%24hu/68c407a8-8ce3-4fba-a037-f96f09e1fd27.png#crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;id=oh5dT&amp;originHeight=649&amp;originWidth=872&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p>
<hr>
<h2 id="use-bcc-to-explore-jvm-usdt">Use BCC to explore JVM USDT</h2>
<pre tabindex="0"><code>readelf -n $JAVA_HOME/jre/lib/amd64/server/libjvm.so | grep -A4 NT_STAPSDT
sudo &lt;path-to&gt;/trace.py -p &lt;java_pid&gt; &#39;u::thread__sleep__begin&#39;
</code></pre><hr>
<h2 id="bpftrace"><code>bpftrace</code></h2>
<blockquote>
<p>one-liner eBPF tools</p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="c1"># list tracepoints</span>
</span></span><span class="line"><span class="cl">bpftrace -l <span class="s1">&#39;tracepoint:syscalls:sys_enter_*&#39;</span>
</span></span><span class="line"><span class="cl"><span class="c1"># trace file open</span>
</span></span><span class="line"><span class="cl">bpftrace -e <span class="s1">&#39;tracepoint:syscalls:sys_enter_openat { printf(&#34;%s %s\n&#34;, comm, str(args-&gt;filename)); }&#39;</span>
</span></span><span class="line"><span class="cl"><span class="c1"># bio size dist</span>
</span></span><span class="line"><span class="cl">bpftrace -e <span class="s1">&#39;tracepoint:block:block_rq_issue { @ = hist(args-&gt;bytes); }&#39;</span>
</span></span></code></pre></div><p><a href="https://github.com/iovisor/bpftrace/blob/master/docs/reference_guide.md#bpftrace-reference-guide">bpftrace Reference Guide</a></p>
<hr>
<h2 id="using-ebpf-to-debug-hotspot-jvmhttpsgithubcomadoptopenjdkopenjdk-buildissues1173"><a href="https://github.com/AdoptOpenJDK/openjdk-build/issues/1173">Using eBPF to debug Hotspot JVM</a></h2>
<ul>
<li>Compile OpenJDK with tracepoints enabled</li>
<li>Use BCC trace tools to trace JVM methods</li>
<li>More Info ref - <a href="https://web.archive.org/web/20161006014657/http://blogs.microsoft.co.il/sasha/2016/03/31/probing-the-jvm-with-bpfbcc/">Probing the JVM with BPF/BCC</a>/[Enable USDT probes for eBPF tracing on Linux #1173</li>
</ul>
<p>](<a href="https://github.com/AdoptOpenJDK/openjdk-build/issues/1173">https://github.com/AdoptOpenJDK/openjdk-build/issues/1173</a>)</p>
<h2 id="ebpf-caveats-and-limitations">eBPF caveats and limitations</h2>
<ul>
<li>Kernel requirement: <code>^4.4</code></li>
<li>Byte code instruction size &lt; 4096</li>
<li>No control loop</li>
</ul>
<hr>
<h2 id="ebpf--xdpexpress-data-path">eBPF &amp; XDP(eXpress Data Path)</h2>
<p>Two ways toward kernel bypass</p>
<ul>
<li>kernel in userspace
<ul>
<li><a href="https://www.dpdk.org/">DPDK</a></li>
<li><a href="https://github.com/luigirizzo/netmap">Netmap</a></li>
</ul>
</li>
<li>user code in kernel
<ul>
<li>XDP</li>
</ul>
</li>
</ul>
<p>XDP Operating modes</p>
<ul>
<li>Native mode
<ul>
<li>Play with DMA buffer</li>
<li>NO SKB ALLOCATON</li>
<li>Least overhead</li>
<li>Need driver modification</li>
</ul>
</li>
<li>SKB mode
<ul>
<li>From <code>netif_receive_skb()</code></li>
<li>After SKB and DMA allocation</li>
<li>More instructions</li>
<li>Driver-Indepent</li>
</ul>
</li>
</ul>
<hr>
<h2 id="xdpcont">XDP(cont.)</h2>
<ul>
<li>Flannel: L2(IP Overlay)</li>
<li>Calico: L3(BGP)</li>
<li>Cilium: L3/4/7 (eBPF/XDP)
<ul>
<li><a href="https://cloud.google.com/blog/products/containers-kubernetes/bringing-ebpf-and-cilium-to-google-kubernetes-engine">GKE2 data plane</a></li>
</ul>
</li>
</ul>
<p><img src="https://gw.alipayobjects.com/zos/antfincdn/SaD3%26t15mG/ab6b1bf1-eacf-49d5-9193-e1adf70c19a7.png#crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;id=iqOuc&amp;originHeight=1694&amp;originWidth=3248&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p>
<p>     Container Network
   </p>
<hr>
<h2 id="cilium-ebpf--xdp-based-cni-plugin">Cilium: eBPF &amp; XDP based CNI plugin</h2>
<p><img src="https://gw.alipayobjects.com/zos/antfincdn/iSIr4xVnkO/73cddcf9-6e5b-4a3f-8fa9-3d8e65b8f056.png#crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;id=abFHP&amp;originHeight=912&amp;originWidth=1600&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p>
<hr>
<h2 id="总结">总结</h2>
<ul>
<li>勇于尝试新 kernel/runtime 和它们的新 feature .</li>
<li>工具可以快速验证思路, 过度依赖工具可能导致一叶障目不见泰山, <strong>核心还是建立对系统的理解</strong>.</li>
</ul>
<p><img src="https://gw.alipayobjects.com/zos/antfincdn/zHvsBUAZw3/f52a93d6-2263-4a2d-bd63-059266789f24.png#crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;id=ZEv9O&amp;originHeight=310&amp;originWidth=325&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><img src="https://gw.alipayobjects.com/zos/antfincdn/HFPHA448hX/85db3710-1a5e-426e-96db-91c514a19cfc.png#crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;id=UjanH&amp;originHeight=324&amp;originWidth=300&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p>
<hr>
<h2 id="reference-1">Reference</h2>
<ul>
<li>
<ol>
<li><a href="https://web.archive.org/web/20161006014657/http://blogs.microsoft.co.il/sasha/2016/03/31/probing-the-jvm-with-bpfbcc/">Probing the JVM with BPF/BCC</a></li>
</ol>
</li>
<li>
<ol start="2">
<li><a href="https://www.evanjones.ca/java-native-leak-bug.html">Debugging Java Native Memory Leaks</a></li>
</ol>
</li>
<li>
<ol start="3">
<li><a href="https://www.usenix.org/sites/default/files/conference/protected-files/srecon18americas_slides_goldshtein.pdf">Goldshtein - Profiling JVM Applications in Production</a></li>
</ol>
</li>
<li>
<ol start="4">
<li><a href="https://lwn.net/Articles/708087/">Debating the value of XDP</a></li>
</ol>
</li>
<li>
<ol start="5">
<li><a href="https://yuque.antfin.com/docs/share/ed2a2941-b51a-497f-b9a1-f393002d0473?#MevjG">OSDI 2020 Summary</a></li>
</ol>
</li>
<li>
<ol start="6">
<li><a href="https://www.usenix.org/conference/osdi20/presentation/brunella">hXDP: Efficient Software Packet Processing on FPGA NICs</a></li>
</ol>
</li>
<li>
<ol start="7">
<li><a href="http://vger.kernel.org/lpc_net2018_talks/presentation-lpc2018-xdp-future.pdf">XDP - challenges and future work</a></li>
</ol>
</li>
<li>
<ol start="8">
<li><a href="https://www.linuxplumbersconf.org/event/2/contributions/71/attachments/17/9/presentation-lpc2018-xdp-tutorial.pdf">A practical introduction to XDP</a></li>
</ol>
</li>
<li>
<ol start="9">
<li><a href="https://docs.cilium.io/en/v1.9/bpf/">BPF and XDP Reference Guide — Cilium 1.9.0 documentation</a></li>
</ol>
</li>
<li>
<ol start="10">
<li><a href="https://www.evanjones.ca/java-native-leak-bug.html">native memory leak</a></li>
</ol>
</li>
<li>
<ol start="11">
<li><a href="https://github.com/netty/netty/pull/3844">epoll native memory leak</a></li>
</ol>
</li>
<li>
<ol start="12">
<li><a href="https://bugs.java.com/bugdatabase/view_bug.do?bug_id=JDK-8164293">JDK-8164293:HotSpot leaking memory</a></li>
</ol>
</li>
<li>
<ol start="13">
<li><a href="https://www.iteye.com/blog/rednaxelafx-1847971">借HSDB来探索HotSpot VM的运行时数据</a></li>
</ol>
</li>
<li>
<ol start="14">
<li><a href="https://bugs.openjdk.java.net/browse/JDK-8158050">JDK-8158050</a></li>
</ol>
</li>
<li>
<ol start="15">
<li><a href="https://yuque.antfin-inc.com/aone355606/gfqllg/xgllfm">JVM团队-JFR使用帮助</a></li>
</ol>
</li>
<li>
<ol start="16">
<li><a href="https://yuque.antfin.com/office/lark/0/2020/pdf/122844/1606645147060-bef1c539-8c2a-4b7e-af40-4a8a5b8cc316.pdf?from=https%3A%2F%2Fyuque.antfin.com%2Fgnu.hl%2Fgnu%2Fxpdq41">JDK Mission Control Tutorial</a></li>
</ol>
</li>
<li>
<ol start="17">
<li><a href="http://hirt.se/blog/">Continuous Production Profiling and Diagnostics</a></li>
</ol>
</li>
<li>
<ol start="18">
<li><a href="https://www.javacodegeeks.com/2015/03/oracle-java-mission-control-the-ultimate-guide.html">Oracle Java Mission Control: The Ultimate Guide</a></li>
</ol>
</li>
<li>
<ol start="19">
<li><a href="http://www.brendangregg.com/perf.html#OneLiners">perf one-liners</a></li>
</ol>
</li>
<li>
<ol start="20">
<li><a href="http://www.brendangregg.com/blog/2015-02-26/linux-perf-off-cpu-flame-graph.html">Off-CPU Analysis</a></li>
</ol>
</li>
<li>
<ol start="21">
<li><a href="http://www.brendangregg.com/perf.html#JIT_Symbols">Bredan Gregg&rsquo;s perf examples</a></li>
</ol>
</li>
<li>
<ol start="22">
<li><a href="https://www.kernel.org/doc/Documentation/kprobes.txt">k{,ret}probes</a></li>
</ol>
</li>
<li>
<ol start="23">
<li><a href="https://lwn.net/Articles/499190/">u{,ret}probes</a></li>
</ol>
</li>
<li>
<ol start="24">
<li><a href="https://static.lwn.net/kerneldoc/trace/tracepoints.html">Kernel tracepoints</a></li>
</ol>
</li>
<li>
<ol start="25">
<li><a href="https://lwn.net/Articles/753601/">USDT</a></li>
</ol>
</li>
<li>
<ol start="26">
<li><a href="https://github.com/iovisor/bpftrace/blob/master/docs/reference_guide.md#bpftrace-reference-guide">bpftrace Reference Guide</a></li>
</ol>
</li>
<li>
<ol start="27">
<li><a href="https://github.com/AdoptOpenJDK/openjdk-build/issues/1173">Use eBPF to debug Hotspot JVM</a></li>
</ol>
</li>
<li>
<ol start="28">
<li><a href="https://github.com/AdoptOpenJDK/openjdk-build/issues/1173">Enable USDT probes for eBPF tracing on Linux #1173</a></li>
</ol>
</li>
<li>
<ol start="29">
<li><a href="https://web.archive.org/web/20161006014657/http://blogs.microsoft.co.il/sasha/2016/03/31/probing-the-jvm-with-bpfbcc/">Probing the JVM with BPF/BCC</a></li>
</ol>
</li>
<li>
<ol start="30">
<li><a href="https://www.evanjones.ca/java-native-leak-bug.html">Debugging Java Native Memory Leaks</a></li>
</ol>
</li>
<li>
<ol start="31">
<li><a href="https://www.usenix.org/sites/default/files/conference/protected-files/srecon18americas_slides_goldshtein.pdf">Goldshtein - Profiling JVM Applications in Production</a></li>
</ol>
</li>
<li>
<ol start="32">
<li><a href="https://lwn.net/Articles/708087/">Debating the value of XDP</a></li>
</ol>
</li>
<li>
<ol start="33">
<li><a href="https://yuque.antfin.com/docs/share/ed2a2941-b51a-497f-b9a1-f393002d0473?#MevjG">OSDI 2020 Summary</a></li>
</ol>
</li>
<li>
<ol start="34">
<li><a href="https://www.usenix.org/conference/osdi20/presentation/brunella">hXDP: Efficient Software Packet Processing on FPGA NICs</a></li>
</ol>
</li>
<li>
<ol start="35">
<li><a href="http://vger.kernel.org/lpc_net2018_talks/presentation-lpc2018-xdp-future.pdf">XDP - challenges and future work</a></li>
</ol>
</li>
<li>
<ol start="36">
<li><a href="https://www.linuxplumbersconf.org/event/2/contributions/71/attachments/17/9/presentation-lpc2018-xdp-tutorial.pdf">A practical introduction to XDP</a></li>
</ol>
</li>
<li>
<ol start="37">
<li><a href="https://docs.cilium.io/en/v1.9/bpf/">BPF and XDP Reference Guide — Cilium 1.9.0 documentation</a></li>
</ol>
</li>
</ul>
<hr>
<h1 id="tribute-to">Tribute To</h1>
<ul>
<li><a href="http://brendangregg.com/">Brendan Gregg</a></li>
<li><a href="https://github.com/goldshtn">Sasha Goldshtein</a></li>
<li><a href="https://jvns.ca/">Julia Evans</a></li>
<li><a href="https://www.iteye.com/blog/user/rednaxelafx">Rednaxelafx</a></li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>Add MathJax and Graphviz support for HUGO</title>
			<link>https://huanglei.rocks/posts/add-math-and-dot-for-hugo/</link>
			<pubDate>Sun, 12 Apr 2020 14:22:22 +0800</pubDate>
			
			<guid>https://huanglei.rocks/posts/add-math-and-dot-for-hugo/</guid>
			<description>Get into your theme folder
  Find some directory named layouts/posts/single.html
  Inside the {{ define main }} block, paste following snippets
  {{ if .Params.viz }} &amp;lt;script type=&amp;#34;text/javascript&amp;#34; src=&amp;#34;https://cdn.bootcss.com/viz.js/1.8.2/viz.js&amp;#34;&amp;gt; &amp;lt;/script&amp;gt; &amp;lt;script type=&amp;#34;text/javascript&amp;#34;&amp;gt; (function(){ var vizPrefix = &amp;#34;language-viz-&amp;#34;; Array.prototype.forEach.call(document.querySelectorAll(&amp;#34;[class^=&amp;#34; + vizPrefix + &amp;#34;]&amp;#34;), function(x){ var engine; x.getAttribute(&amp;#34;class&amp;#34;).split(&amp;#34; &amp;#34;).forEach(function(cls){ if (cls.startsWith(vizPrefix)) { engine = cls.substr(vizPrefix.length); } }); var image = new DOMParser().parseFromString(Viz(x.innerText, {format:&amp;#34;svg&amp;#34;, engine:engine}), &amp;#34;image/svg+xml&amp;#34;); x.parentNode.insertBefore(image.documentElement, x); x.</description>
			<content type="html"><![CDATA[<ol>
<li>
<p>Get into your theme folder</p>
</li>
<li>
<p>Find some directory named <code>layouts/posts/single.html</code></p>
</li>
<li>
<p>Inside the <code>{{ define main }}</code> block, paste following snippets</p>
</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="p">{{</span> <span class="k">if</span> <span class="p">.</span><span class="nx">Params</span><span class="p">.</span><span class="nx">viz</span> <span class="p">}}</span>
</span></span><span class="line"><span class="cl">  <span class="o">&lt;</span><span class="nx">script</span> <span class="nx">type</span><span class="o">=</span><span class="s2">&#34;text/javascript&#34;</span> <span class="nx">src</span><span class="o">=</span><span class="s2">&#34;https://cdn.bootcss.com/viz.js/1.8.2/viz.js&#34;</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="err">/script&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="o">&lt;</span><span class="nx">script</span> <span class="nx">type</span><span class="o">=</span><span class="s2">&#34;text/javascript&#34;</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="p">(</span><span class="kd">function</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">    <span class="kd">var</span> <span class="nx">vizPrefix</span> <span class="o">=</span> <span class="s2">&#34;language-viz-&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nb">Array</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">forEach</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nb">document</span><span class="p">.</span><span class="nx">querySelectorAll</span><span class="p">(</span><span class="s2">&#34;[class^=&#34;</span> <span class="o">+</span> <span class="nx">vizPrefix</span> <span class="o">+</span> <span class="s2">&#34;]&#34;</span><span class="p">),</span> <span class="kd">function</span><span class="p">(</span><span class="nx">x</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">      <span class="kd">var</span> <span class="nx">engine</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="nx">x</span><span class="p">.</span><span class="nx">getAttribute</span><span class="p">(</span><span class="s2">&#34;class&#34;</span><span class="p">).</span><span class="nx">split</span><span class="p">(</span><span class="s2">&#34; &#34;</span><span class="p">).</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">cls</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="nx">cls</span><span class="p">.</span><span class="nx">startsWith</span><span class="p">(</span><span class="nx">vizPrefix</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="nx">engine</span> <span class="o">=</span> <span class="nx">cls</span><span class="p">.</span><span class="nx">substr</span><span class="p">(</span><span class="nx">vizPrefix</span><span class="p">.</span><span class="nx">length</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="p">});</span>
</span></span><span class="line"><span class="cl">      <span class="kd">var</span> <span class="nx">image</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">DOMParser</span><span class="p">().</span><span class="nx">parseFromString</span><span class="p">(</span><span class="nx">Viz</span><span class="p">(</span><span class="nx">x</span><span class="p">.</span><span class="nx">innerText</span><span class="p">,</span> <span class="p">{</span><span class="nx">format</span><span class="o">:</span><span class="s2">&#34;svg&#34;</span><span class="p">,</span> <span class="nx">engine</span><span class="o">:</span><span class="nx">engine</span><span class="p">}),</span> <span class="s2">&#34;image/svg+xml&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="nx">x</span><span class="p">.</span><span class="nx">parentNode</span><span class="p">.</span><span class="nx">insertBefore</span><span class="p">(</span><span class="nx">image</span><span class="p">.</span><span class="nx">documentElement</span><span class="p">,</span> <span class="nx">x</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="nx">x</span><span class="p">.</span><span class="nx">style</span><span class="p">.</span><span class="nx">display</span> <span class="o">=</span> <span class="s1">&#39;none&#39;</span>
</span></span><span class="line"><span class="cl">      <span class="nx">x</span><span class="p">.</span><span class="nx">parentNode</span><span class="p">.</span><span class="nx">style</span><span class="p">.</span><span class="nx">backgroundColor</span> <span class="o">=</span> <span class="s2">&#34;white&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="p">});</span>
</span></span><span class="line"><span class="cl">  <span class="p">})();</span>
</span></span><span class="line"><span class="cl">  <span class="o">&lt;</span><span class="err">/script&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">{{</span> <span class="nx">end</span> <span class="p">}}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">{{</span> <span class="k">if</span>  <span class="p">.</span><span class="nx">Params</span><span class="p">.</span><span class="nx">math</span>   <span class="p">}}</span>
</span></span><span class="line"><span class="cl">  <span class="o">&lt;</span><span class="nx">script</span> <span class="nx">type</span><span class="o">=</span><span class="s2">&#34;text/javascript&#34;</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nb">window</span><span class="p">.</span><span class="nx">MathJax</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">tex2jax</span><span class="o">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">inlineMath</span><span class="o">:</span> <span class="p">[[</span><span class="s1">&#39;$&#39;</span><span class="p">,</span><span class="s1">&#39;$&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;\\(&#39;</span><span class="p">,</span><span class="s1">&#39;\\)&#39;</span><span class="p">]],</span>
</span></span><span class="line"><span class="cl">        <span class="nx">displayMath</span><span class="o">:</span> <span class="p">[[</span><span class="s1">&#39;$$&#39;</span><span class="p">,</span><span class="s1">&#39;$$&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;\[&#39;</span><span class="p">,</span><span class="s1">&#39;\]&#39;</span><span class="p">]],</span>
</span></span><span class="line"><span class="cl">        <span class="nx">processEscapes</span><span class="o">:</span> <span class="kc">true</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="nx">processEnvironments</span><span class="o">:</span> <span class="kc">true</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="nx">skipTags</span><span class="o">:</span> <span class="p">[</span><span class="s1">&#39;script&#39;</span><span class="p">,</span> <span class="s1">&#39;noscript&#39;</span><span class="p">,</span> <span class="s1">&#39;style&#39;</span><span class="p">,</span> <span class="s1">&#39;textarea&#39;</span><span class="p">,</span> <span class="s1">&#39;pre&#39;</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">        <span class="nx">TeX</span><span class="o">:</span> <span class="p">{</span> <span class="nx">equationNumbers</span><span class="o">:</span> <span class="p">{</span> <span class="nx">autoNumber</span><span class="o">:</span> <span class="s2">&#34;AMS&#34;</span> <span class="p">},</span>
</span></span><span class="line"><span class="cl">          <span class="nx">extensions</span><span class="o">:</span> <span class="p">[</span><span class="s2">&#34;AMSmath.js&#34;</span><span class="p">,</span> <span class="s2">&#34;AMSsymbols.js&#34;</span><span class="p">,</span> <span class="s2">&#34;color.js&#34;</span><span class="p">]</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="p">},</span>
</span></span><span class="line"><span class="cl">      <span class="nx">AuthorInit</span><span class="o">:</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">MathJax</span><span class="p">.</span><span class="nx">Hub</span><span class="p">.</span><span class="nx">Register</span><span class="p">.</span><span class="nx">StartupHook</span><span class="p">(</span><span class="s2">&#34;Begin&#34;</span><span class="p">,</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="nx">MathJax</span><span class="p">.</span><span class="nx">Hub</span><span class="p">.</span><span class="nx">Queue</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="kd">var</span> <span class="nx">all</span> <span class="o">=</span> <span class="nx">MathJax</span><span class="p">.</span><span class="nx">Hub</span><span class="p">.</span><span class="nx">getAllJax</span><span class="p">(),</span> <span class="nx">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">for</span><span class="p">(</span><span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">all</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">              <span class="nx">all</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">SourceElement</span><span class="p">().</span><span class="nx">parentNode</span><span class="p">.</span><span class="nx">className</span> <span class="o">+=</span> <span class="s1">&#39; has-jax&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">          <span class="p">})</span>
</span></span><span class="line"><span class="cl">        <span class="p">});</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">};</span>
</span></span><span class="line"><span class="cl">  <span class="o">&lt;</span><span class="err">/script&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="o">&lt;</span><span class="nx">script</span>  <span class="nx">type</span><span class="o">=</span><span class="s2">&#34;text/javascript&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="nx">src</span><span class="o">=</span><span class="s2">&#34;https://cdn.bootcss.com/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML&#34;</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="o">&lt;</span><span class="err">/script&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">{{</span> <span class="nx">end</span> <span class="p">}}</span>
</span></span></code></pre></div><ol start="4">
<li>Create some posts and add following config inside front-matter</li>
</ol>
<pre tabindex="0"><code>viz: true
math: true
</code></pre><p>And try some graphviz and mathjax stuff!</p>
<p><img src="/images/mathjax-dot-demo.png" alt="mathjax-dot-demo"></p>
<blockquote>
<p>You may check the demo <a href="/posts/math-and-dot-demo">here</a></p>
</blockquote>
]]></content>
		</item>
		
		<item>
			<title>Graphviz and mathjax demo</title>
			<link>https://huanglei.rocks/posts/math-and-dot-demo/</link>
			<pubDate>Sat, 11 Apr 2020 23:26:41 +0800</pubDate>
			
			<guid>https://huanglei.rocks/posts/math-and-dot-demo/</guid>
			<description>digraph g{ rankdir=LR; node [shape=record,width=01,height=.1]; a[label=&amp;#34;&amp;lt;1&amp;gt;Hash Table|&amp;lt;2&amp;gt;Node|&amp;lt;3&amp;gt;Node|...|&amp;lt;4&amp;gt;TreeNode&amp;#34;]; { // graph[rankdir=LR] node1[label=&amp;#34;{&amp;lt;1&amp;gt;A1|&amp;lt;2&amp;gt;A2|...|An}&amp;#34;] node2[label=&amp;#34;{&amp;lt;1&amp;gt;B1|&amp;lt;2&amp;gt;B2|...|Bn}&amp;#34;] // node3[label=&amp;#34;{&amp;lt;1&amp;gt;C1|&amp;lt;2&amp;gt;C2}&amp;#34;] subgraph cluster_treenode{ penwidth=0; node[shape=circle]; root[label=&amp;#34;&amp;#34;, style=filled,fillcolor=black,width=.2]; n1[label=&amp;#34;&amp;#34;, style=filled,fillcolor=red,width=.2] n2[label=&amp;#34;&amp;#34;, style=filled,fillcolor=black,width=.2] n3[label=&amp;#34;&amp;#34;, style=filled,fillcolor=black,width=.2] n4[label=&amp;#34;&amp;#34;, style=filled,fillcolor=red,width=.2] n5[label=&amp;#34;&amp;#34;, style=filled,fillcolor=black,width=.2] n6[label=&amp;#34;&amp;#34;, style=filled,fillcolor=black,width=.2] root-&amp;gt;n1; n1-&amp;gt;n2; n1-&amp;gt;n3; root-&amp;gt;n4; n4-&amp;gt;n5; n4-&amp;gt;n6; } } a:2:e-&amp;gt;node1:1 [style=dashed]; a:3:e-&amp;gt;node2:1; a:4:e-&amp;gt;root; // node3:d-&amp;gt;node3:sa2; } $$f(a) = \frac{1}{2\pi i} \oint\frac{f(z)}{z-a}dz$$</description>
			<content type="html"><![CDATA[<pre tabindex="0"><code class="language-viz-dot" data-lang="viz-dot">digraph g{
    rankdir=LR;
    node [shape=record,width=01,height=.1];
	a[label=&#34;&lt;1&gt;Hash Table|&lt;2&gt;Node|&lt;3&gt;Node|...|&lt;4&gt;TreeNode&#34;];
    {
        // graph[rankdir=LR]    
        node1[label=&#34;{&lt;1&gt;A1|&lt;2&gt;A2|...|An}&#34;]
        node2[label=&#34;{&lt;1&gt;B1|&lt;2&gt;B2|...|Bn}&#34;]
        // node3[label=&#34;{&lt;1&gt;C1|&lt;2&gt;C2}&#34;]
        subgraph cluster_treenode{
            penwidth=0;
            node[shape=circle];
            root[label=&#34;&#34;, style=filled,fillcolor=black,width=.2];
            n1[label=&#34;&#34;, style=filled,fillcolor=red,width=.2]
            n2[label=&#34;&#34;, style=filled,fillcolor=black,width=.2]
            n3[label=&#34;&#34;, style=filled,fillcolor=black,width=.2]
            n4[label=&#34;&#34;, style=filled,fillcolor=red,width=.2]
            n5[label=&#34;&#34;, style=filled,fillcolor=black,width=.2]
            n6[label=&#34;&#34;, style=filled,fillcolor=black,width=.2]
            root-&gt;n1;
            n1-&gt;n2;
            n1-&gt;n3;
            root-&gt;n4;
            n4-&gt;n5;
            n4-&gt;n6;
        }
    }
    
    a:2:e-&gt;node1:1 [style=dashed];
    a:3:e-&gt;node2:1;    
    a:4:e-&gt;root;    

    // node3:d-&gt;node3:sa2;
}
</code></pre><p>$$f(a) = \frac{1}{2\pi i} \oint\frac{f(z)}{z-a}dz$$</p>
]]></content>
		</item>
		
	</channel>
</rss>
