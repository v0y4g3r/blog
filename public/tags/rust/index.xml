<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Rust on Tokamako</title>
    <link>https://huanglei.rocks/tags/rust/</link>
    <description>Recent content in Rust on Tokamako</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
    <lastBuildDate>Thu, 09 Dec 2021 21:57:33 +0800</lastBuildDate><atom:link href="https://huanglei.rocks/tags/rust/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Rust 对象安全详解</title>
      <link>https://huanglei.rocks/posts/object-safety/</link>
      <pubDate>Thu, 09 Dec 2021 21:57:33 +0800</pubDate>
      
      <guid>https://huanglei.rocks/posts/object-safety/</guid>
      <description>Rust 的 RFC 上只给出了 object-safety 的定义，但是没有解释为何在满足这些条件的时候 trait 是 object safe 的，以及为啥需要 object safety，这反而是初学者最为困惑的点。
为什么需要 object safety？ Rust 通过 trait object 提供了类型擦除、动态分派的能力，但是这个能力是有限制的，不是所有的 trait 都能自动生成实现。 Trait object 本质上是对某个 trait 的自动默认实现，包括一个数据区和一个方法表。Object-safety 就是为了保证 Rust 编译器能够为某个 trait 生成合法自动实现。
 Trait object 的内存布局    Where Self Meets Sized: Revisiting Object Safety
 首先是关于 trait 的 object safety，一个 trait 是对象安全的，当且仅当它满足以下所有条件：
 trait 的类型不能限定为 Self: Sized1️⃣； trait 中所定义的所有方法都是 object-safe 的2️⃣；  接下来是关于方法的 object safety：一个方法是对象安全的，当且仅当这个方法满足下面任意一个特性：
 方法 receiver 的类型限定是 Self: Sized3️⃣ ；或者 满足以下所有条件：  方法不能有泛型参数4️⃣；且 receiver 类型必须是 Self 或者可以解引用为 Self 的引用类型5️⃣ 。目前只包括self/ &amp;amp;self / &amp;amp;mut self/ self: Box&amp;lt;Self&amp;gt;。以后可能也会扩展到 Rc&amp;lt;Self&amp;gt;等等。 Self类型只能用作 receiver 6️⃣     1️⃣ 也就是说，如下的 trait 是不能用作 trait object 的。</description>
    </item>
    
  </channel>
</rss>
