<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>Posts on Tokamako</title>
		<link>https://huanglei.rocks/posts/</link>
		<description>Recent content in Posts on Tokamako</description>
		<generator>Hugo -- gohugo.io</generator>
		<language>en-us</language>
		<copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
		<lastBuildDate>Sat, 05 Mar 2022 15:44:33 +0800</lastBuildDate>
		<atom:link href="https://huanglei.rocks/posts/index.xml" rel="self" type="application/rss+xml" />
		
		<item>
			<title>Apache Parquet 格式简介</title>
			<link>https://huanglei.rocks/posts/parquet/</link>
			<pubDate>Sat, 05 Mar 2022 15:44:33 +0800</pubDate>
			
			<guid>https://huanglei.rocks/posts/parquet/</guid>
			<description>简介 Parquet 是一种面向列的数据存储格式，在 Hadoop 生态中使用广泛。Parquet 文件是不可变的，如果需要修改，只能通过 rewrite 的方式实现。
数据 layout 一个 Parquet 文件的数据布局如下图所示。需要注意的是，官网上的这个图并没有包含 index pages。
 官方的格式图    原始行格式的数据    Parquet 数据的遍历顺序    使用 Parquet 转换之后的格式   在 Parquet 中，数据每隔若干行被分作一个 row group；在同一个 row group 中，不同 row 的相同列被连续存储在一起。连续的列再间隔若干行会被分割为一个页（page）。
元数据 从如上的 Parquet 格式可以看出来，一个 Parquet 文件是包含了一些元数据的，比如 footer、page header 等等，这些元数据可以在读取 parquet 文件的时候提供相关信息来加速遍历。
Footer Footer 是整个 Parquet 文件的元数据，从 footer 可以得到文件的版本、数据 schema、row group 的元数据、row group 中的每一列的元数据等等。
Footer 位于 Parquet 的末尾，因此可以从文件结尾 seek 到倒数第 8 到倒数第 4 字节，作为 footer 的长度，从而得到 footer 区的起始 offset。</description>
			<content type="html"><![CDATA[<h2 id="简介">简介</h2>
<p>Parquet 是一种面向列的数据存储格式，在 Hadoop 生态中使用广泛。Parquet 文件是不可变的，如果需要修改，只能通过 rewrite 的方式实现。</p>
<h2 id="数据-layout">数据 layout</h2>
<p>一个 Parquet 文件的数据布局如下图所示。需要注意的是，官网上的这个图并没有包含 index pages。</p>
<p><img src="https://raw.githubusercontent.com/apache/parquet-format/master/doc/images/FileLayout.gif#crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;id=gFbsV&amp;originHeight=478&amp;originWidth=601&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p>
<div style="text-align: center;">
<i>
 官方的格式图  
</i>
</div>
<p><img src="https://cdn.jsdelivr.net/gh/RayneHwang/img-repo/parquet-original-light.svg" alt=""></p>
<div style="text-align: center;">
<i>
 原始行格式的数据  
</i>
</div>
<p><img src="https://cdn.jsdelivr.net/gh/RayneHwang/img-repo/parquet-iteration-order-light.svg" alt=""></p>
<div style="text-align: center;">
<i>
 Parquet 数据的遍历顺序 
</i>
</div>
<p><img src="https://cdn.jsdelivr.net/gh/RayneHwang/img-repo/parquet-physical-light.svg" alt=""></p>
<div style="text-align: center;">
<i>
 使用 Parquet 转换之后的格式 
</i>
</div>
<p>在 Parquet 中，数据每隔若干行被分作一个 row group；在同一个 row group 中，不同 row 的相同列被连续存储在一起。连续的列再间隔若干行会被分割为一个页（page）。</p>
<h2 id="元数据">元数据</h2>
<p><img src="https://raw.github.com/apache/parquet-format/master/doc/images/FileLayout.gif" alt="image.png"></p>
<p>从如上的 Parquet 格式可以看出来，一个 Parquet 文件是包含了一些元数据的，比如 footer、page header 等等，这些元数据可以在读取 parquet 文件的时候提供相关信息来加速遍历。</p>
<h3 id="footer">Footer</h3>
<p>Footer 是整个 Parquet 文件的元数据，从 footer 可以得到文件的版本、数据 schema、row group 的元数据、row group 中的每一列的元数据等等。</p>
<p>Footer 位于 Parquet 的末尾，因此可以从文件结尾 seek 到倒数第 8 到倒数第 4 字节，作为 footer 的长度，从而得到 footer 区的起始 offset。</p>
<p>Footer 区数据遵循特定的编码格式（ThriftCompactProtocol），因此可以方便地反序列化。</p>
<p>Footer 区还包含了 row group 和 row group 中的列的信息。</p>
<h3 id="列的元数据">列的元数据</h3>
<p><img src="https://cdn.jsdelivr.net/gh/RayneHwang/img-repo/20220305160426.png" alt=""></p>
<div style="text-align: center;">
<i>
  列的元数据位置  
</i>
</div>
<p>在 footer 中，每一列的信息也被记录，包括：</p>
<ul>
<li>列的类型、编码；</li>
<li>列值的数量；</li>
<li>第一个数据页的 offset；</li>
<li>第一个索引页的 offset；</li>
<li>压测/解压缩的大小；</li>
<li>以及一些额外的键值对。</li>
</ul>
<p>根据 footer 中的这些列的信息就可以快速找到 Parquet 文件中的数据地址和索引地址、以及如何解析这些数据。</p>
<h3 id="文件内索列">文件内索列</h3>
<p><a href="https://issues.apache.org/jira/browse/PARQUET-1201">Parquet 2.5 版本</a>支持了列值索引功能，具体的功能介绍可以参考 <a href="https://github.com/apache/parquet-format/blob/master/PageIndex.md">ColumnIndex Layout to Support Page Skipping</a>.</p>
<p>在之前的版本中，统计数据（min、max）只在 column 的 metadata 和 page header 当中，当读取 page 的时候，可以根据 page header 中的统计数据决定是否需要跳过这一页，但这样还是需要遍历文件中的每一页。</p>
<p>目标：通过 minmax 可以直接定位到 page 的方式提高范围查询和点查的 IO 效率。具体来说针对 row group 排序列的单行查询，每一列只需要读取一页数据。排序列的范围查询只读取范围所涉及的数据页；如果其他的查询具有高选择性，即使查询条件不是排序列，也要能够按需读取数据页。</p>
<p>为了实现这样的目标，Parquet 在 row group 的元数据上增加了如下两个针对列的数据结构（即在一个 row group 中的每一个列都有下面的两个索引来描述它们）：</p>
<ul>
<li>ColumnIndex：针对 scan predicate，支持通过列值找到列的数据所在的页；</li>
<li>OffsetIndex：通过 ColumnIndex 找到 match 的 row 之后，OffsetIndex 支持按 row index 去获取相应的值。一个 row group 的所有 column 的 OffsetIndex 都是存储在一起的。</li>
</ul>
<p>索引的地址在 footer 区之前的地方，footer 里面有一个字段指明了其 offset。</p>
<p><img src="https://cdn.jsdelivr.net/gh/RayneHwang/img-repo/parquet-index-page-location-light.svg#crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;id=KmMZf&amp;originHeight=202&amp;originWidth=382&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p>
<div style="text-align: center;">
<i>
 Index page 的位置 
</i>
</div>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="sd">/// Description for ColumnIndex.
</span></span></span><span class="line"><span class="cl"><span class="sd">/// Each &lt;array-field&gt;[i] refers to the page at OffsetIndex.page_locations[i]
</span></span></span><span class="line"><span class="cl"><span class="sd"></span><span class="cp">#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">ColumnIndex</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="sd">/// A list of Boolean values to determine the validity of the corresponding
</span></span></span><span class="line"><span class="cl"><span class="sd"></span><span class="w">  </span><span class="sd">/// min and max values. If true, a page contains only null values, and writers
</span></span></span><span class="line"><span class="cl"><span class="sd"></span><span class="w">  </span><span class="sd">/// have to set the corresponding entries in min_values and max_values to
</span></span></span><span class="line"><span class="cl"><span class="sd"></span><span class="w">  </span><span class="sd">/// byte[0], so that all lists have the same length. If false, the
</span></span></span><span class="line"><span class="cl"><span class="sd"></span><span class="w">  </span><span class="sd">/// corresponding entries in min_values and max_values must be valid.
</span></span></span><span class="line"><span class="cl"><span class="sd"></span><span class="w">  </span><span class="k">pub</span><span class="w"> </span><span class="n">null_pages</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="sd">/// Two lists containing lower and upper bounds for the values of each page.
</span></span></span><span class="line"><span class="cl"><span class="sd"></span><span class="w">  </span><span class="sd">/// These may be the actual minimum and maximum values found on a page, but
</span></span></span><span class="line"><span class="cl"><span class="sd"></span><span class="w">  </span><span class="sd">/// can also be (more compact) values that do not exist on a page. For
</span></span></span><span class="line"><span class="cl"><span class="sd"></span><span class="w">  </span><span class="sd">/// example, instead of storing &#34;&#34;Blart Versenwald III&#34;, a writer may set
</span></span></span><span class="line"><span class="cl"><span class="sd"></span><span class="w">  </span><span class="sd">/// min_values[i]=&#34;B&#34;, max_values[i]=&#34;C&#34;. Such more compact values must still
</span></span></span><span class="line"><span class="cl"><span class="sd"></span><span class="w">  </span><span class="sd">/// be valid values within the column&#39;s logical type. Readers must make sure
</span></span></span><span class="line"><span class="cl"><span class="sd"></span><span class="w">  </span><span class="sd">/// that list entries are populated before using them by inspecting null_pages.
</span></span></span><span class="line"><span class="cl"><span class="sd"></span><span class="w">  </span><span class="k">pub</span><span class="w"> </span><span class="n">min_values</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">u8</span><span class="o">&gt;&gt;</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="k">pub</span><span class="w"> </span><span class="n">max_values</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">u8</span><span class="o">&gt;&gt;</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="sd">/// Stores whether both min_values and max_values are orderd and if so, in
</span></span></span><span class="line"><span class="cl"><span class="sd"></span><span class="w">  </span><span class="sd">/// which direction. This allows readers to perform binary searches in both
</span></span></span><span class="line"><span class="cl"><span class="sd"></span><span class="w">  </span><span class="sd">/// lists. Readers cannot assume that max_values[i] &lt;= min_values[i+1], even
</span></span></span><span class="line"><span class="cl"><span class="sd"></span><span class="w">  </span><span class="sd">/// if the lists are ordered.
</span></span></span><span class="line"><span class="cl"><span class="sd"></span><span class="w">  </span><span class="k">pub</span><span class="w"> </span><span class="n">boundary_order</span>: <span class="nc">BoundaryOrder</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="sd">/// A list containing the number of null values for each page *
</span></span></span><span class="line"><span class="cl"><span class="sd"></span><span class="w">  </span><span class="k">pub</span><span class="w"> </span><span class="n">null_counts</span>: <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">i64</span><span class="o">&gt;&gt;</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="cp">#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">OffsetIndex</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="sd">/// PageLocations, ordered by increasing PageLocation.offset. It is required
</span></span></span><span class="line"><span class="cl"><span class="sd"></span><span class="w">  </span><span class="sd">/// that page_locations[i].first_row_index &lt; page_locations[i+1].first_row_index.
</span></span></span><span class="line"><span class="cl"><span class="sd"></span><span class="w">  </span><span class="k">pub</span><span class="w"> </span><span class="n">page_locations</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">PageLocation</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><h2 id="parquet-的优势">Parquet 的优势</h2>
<ul>
<li>按需读取列的值，比如在 OLAP 场景下，大宽表往往最终只有少量的列会被读取到；</li>
<li>自描述，自带 schema，支持数据结构嵌套；</li>
<li>由于列保存在一起，因此可以提高压缩和编码的效率（比如 RLE、字典压、Bit Packing 等等）;</li>
<li>文件自带索引，支持快速检索 data page。</li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>BookKeeper 笔记</title>
			<link>https://huanglei.rocks/posts/bookkeeper-note/</link>
			<pubDate>Thu, 24 Feb 2022 01:18:35 +0800</pubDate>
			
			<guid>https://huanglei.rocks/posts/bookkeeper-note/</guid>
			<description>BookKeeper 的使用场景  WAL：比如 HDFS Namenode 的 EditLog（要求高可靠） 分布式存储：比如 Pulsar 的消息存储、DistributedLog 等  核心理念  通过条带化写（Data Striping）实现数据的多副本，所有存储节点角色对等； 通过其他的存储组件（ZooKeeper）实现元数据高可靠，故障恢复（recover）流程强依赖 ZK 的元数据；  也可以选用其他的存储服务，要求 1. CP 系统；2. 提供 CAS 原语   基于 RocksDB 提供 (ledger, sequence) -&amp;gt; (file, physicalOffset) 的索引（SingleDirectoryDbLedgerStorage#ledgerIndex）； 同一时刻只有一个 writer 和多个 reader，通过 fencing 机制避免出现多 writer，避免 sequence 乱序； 读写分离，冷热分离（tailing read/catch-up read）提高吞吐；  BookKeeper 的术语  ledger：一写多读的 append-only 文件，ledger 的最小数据单元是 fragment； bookie：存储 ledger 的节点； ledger has many records， called：entry，每个entry都有一个 sequence number，可以根据 ledger + seq 来读取一部分 entry。 quorum：几个 bookie 组成一个 quorum，通过复制提高可用性。 data striping：数据块交织写入到各个设备，提高写入的性能。类似 RAID1 的机制。   BookKeeper 的 quorum write 机制   Striping 很容易就会导致读取者所看到的 log 不一致，因此 BK 引入了 ZK 去保存元数据，并且通过 triming 机制（BK 称为 reader-initiated ledger recovery）来确保末尾未完整写完整个 quorum 的数据能够被安全删除并且对 reader 不可见。</description>
			<content type="html"><![CDATA[<h1 id="bookkeeper-的使用场景">BookKeeper 的使用场景</h1>
<ul>
<li>WAL：比如 HDFS Namenode 的 EditLog（要求高可靠）</li>
<li>分布式存储：比如 Pulsar 的消息存储、DistributedLog 等</li>
</ul>
<h1 id="核心理念">核心理念</h1>
<ul>
<li>通过条带化写（Data Striping）实现数据的多副本，所有存储节点角色对等；</li>
<li>通过其他的存储组件（ZooKeeper）实现元数据高可靠，故障恢复（recover）流程强依赖 ZK 的元数据；
<ul>
<li>也可以选用其他的存储服务，要求 1. CP 系统；2. 提供 CAS 原语</li>
</ul>
</li>
<li>基于 RocksDB 提供 <code>(ledger, sequence) -&gt; (file, physicalOffset)</code>  的索引（<code>SingleDirectoryDbLedgerStorage#ledgerIndex</code>）；</li>
<li>同一时刻只有一个 writer 和多个 reader，通过 fencing 机制避免出现多 writer，避免 sequence 乱序；</li>
<li>读写分离，冷热分离（tailing read/catch-up read）提高吞吐；</li>
</ul>
<h1 id="bookkeeper-的术语">BookKeeper 的术语</h1>
<ul>
<li>ledger：一写多读的 append-only 文件，ledger 的最小数据单元是 fragment；</li>
<li>bookie：存储 ledger 的节点；</li>
<li>ledger has many records， called：entry，每个entry都有一个 sequence number，可以根据 ledger + seq 来读取一部分 entry。</li>
<li>quorum：几个 bookie 组成一个 quorum，通过复制提高可用性。</li>
<li>data striping：数据块交织写入到各个设备，提高写入的性能。类似 RAID1 的机制。</li>
</ul>
<p><img src="https://huanglei-rocks-blog.oss-cn-shanghai.aliyuncs.com/blog/20220224230803.png" alt=""></p>
<div style="text-align: center;">
<i>
 BookKeeper 的 quorum write 机制 
</i>
</div>
<p>Striping 很容易就会导致读取者所看到的 log 不一致，因此 BK 引入了 ZK 去保存元数据，并且通过 triming 机制（BK 称为 reader-initiated ledger recovery）来确保末尾未完整写完整个 quorum 的数据能够被安全删除并且对 reader 不可见。</p>
<h1 id="实现细节">实现细节</h1>
<h2 id="bookie-的结构">Bookie 的结构</h2>
<p>Bookie 是存储节点，具体包含两个模块：</p>
<ul>
<li>journal：WAL，同步写，负责保存 writer 的写入操作；</li>
<li>ledger：包含内存的状态（memtable）、ledger 的索引等，异步写。</li>
</ul>
<p><img src="https://huanglei-rocks-blog.oss-cn-shanghai.aliyuncs.com/blog/20220224231150.png" alt=""></p>
<div style="text-align: center;">
<i>
 BookKeeper 的读写路径 
</i>
</div>
<p>理想状况下，journal 和 ledger 应该位于不同的磁盘上，减少他们同时不可用的概率。</p>
<h2 id="bookkeeper-提供的-api">BookKeeper 提供的 API</h2>
<ul>
<li>创建 ledger</li>
<li>向 ledger 新增 entry</li>
<li>打开一个 ledger</li>
<li>从ledger 读取 entry</li>
<li>关闭 ledger 避免后续数据写入</li>
<li>删除一个ledger</li>
</ul>
<h2 id="ledger-操作">Ledger 操作</h2>
<h3 id="ledger-创建">Ledger 创建</h3>
<p>一个 ledger 需要由一个 ensemble 来负责，因此创建 ledger 的时候必须指定 ledger 的 quorum 和 ensemble。具备 f+1 个节点的 quorum 可以容忍 f 个节点宕机。</p>
<ul>
<li>quorum：写入节点集合。更大的quorum 提供更强的可用性。</li>
<li>ensemble：striping 所需要的节点总数。更大的 ensemble 提供更大的吞吐。</li>
</ul>
<p><img src="https://huanglei-rocks-blog.oss-cn-shanghai.aliyuncs.com/blog/paper-creating-using-ledger.png?versionId=CAEQIBiBgMDlsZax.RciIGJmZGJjYjRjODNiZjQ4ZDE4OWZkMjVlZWRhNmEzMGJh" alt="paper-creating-using-ledger.png"></p>
<ul>
<li>quorum 是以 round-robin 的形式分散在整个 ensemble 中。</li>
<li>quorum 和 ensemble 这些元数据保存在 zookeeper 中。</li>
</ul>
<blockquote>
<p>这里有个问题，当bk客户端尝试读取 entry 的时候，需要确定从哪些bookie组成的quorum 读取，那这个quorum是怎么确定的？</p>
</blockquote>
<p><img src="https://huanglei-rocks-blog.oss-cn-shanghai.aliyuncs.com/blog/paper-to-read-a-given-entry-e.png?versionId=CAEQIBiBgICTgJmx.RciIGNmMjU4OWFmYTE0YjQ4NzFiNjY0MTM4NzRjZjNjZTJi" alt="image.png"></p>
<h3 id="ledger-关闭">Ledger 关闭</h3>
<p>Ledger 关闭是一个原子的操作，会在 ZK 中记录 ledger 最后一个 entry 的 seq。这里ZK 提供的一致性协议非常重要，否则 Bookkeper 的客户端可能会观察到 ledger 的 不一致。
<img src="https://huanglei-rocks-blog.oss-cn-shanghai.aliyuncs.com/blog/1635067390415-cdc4ede3-9bd7-4bd3-82e7-f3c3091be3d1.png" alt="paper-closing-a-ledger">
当 BK 的客户端没有 close 一个ledger 就 crash 怎么办？因此需要一个额外的机制来保证所有 open 的ledger 都能够最终被 close。</p>
<h3 id="ledger-的恢复">Ledger 的恢复</h3>
<p>Ledger 的写入者可能在没关闭 ledger 的时候就 crash 了，这种情况下 entry 的元数据尚未更新到 zk中， ledger 的读取者无法安全地确认 ledger中的最后的 entry 是什么，因此 ledger 需要 恢复操作（recovery）。</p>
<p>当 reader 打开一个 ledger 读取的时候，从 ZK 中获取元数据，同时如果发现这个 ledger 尚未被 close，就触发一个 recovery 流程。</p>
<p>Recovery：确定按所要求的 quorum 写入成功的最后一个 entry，写入到 ZK 中。</p>
<blockquote>
<p>如何确认最后一个 entry？可以简单地从 ledger 一次读取所有的entry，重新写入一遍。
为了加速，reader 向 ensemble 中所有的 bookie 询问 此ledger 写入的最新的 entry 的LAC字段（Last Add Confirmed）。然后恢复流程就可以从最高的 LAC 位置开始，而无需读取整个 ledger。</p>
</blockquote>
<h3 id="lac">LAC</h3>
<p>LAC：Last add confirmed，获取一个 quorum 中最后一个被确认写入的 entry 的 id
对于 单个 bookie 而言，所谓的LAC就是当前 ledger 最后一个写入的 entry 的 entry id。而对于客户端而言，获取quorum 的LAC就是获取整个 quorum 中最大的LAC。</p>
<p><strong>这里比较容易混淆：LAC 应该是维护在 writer 本地的，只是每次写入到 bookie 的时候把它放在 entry 的某个字段中。Quorum 中所有 bookie 的最后一个 entry 的 LAC 最大值，所反映的一定是这个 writer 的 LAC 的最大值，这样一来 LAC 的作用就好理解了，相当于是把 writer 的写入确认水位状态随着 entry 写入到了每一个 bookie中。</strong></p>
<blockquote>
<p><strong>这块的介绍可以看 <strong><a href="https://bookkeeper.apache.org/distributedlog/docs/latest/user_guide/design/main.html"><strong>DistributedLog</strong></a></strong>。</strong></p>
</blockquote>
<h1 id="fencing">Fencing</h1>
<p>LAC 只能保证 reader 之间读取的一致性，但是不能避免出现多个 writer。</p>
<p>bookie 检测到某个 ledger 出于 recovery 流程中时，拒绝掉所有这个ledger 写入的请求。</p>
<h3 id="从一个-open-状态的-ledger-读取数据">从一个 open 状态的 ledger 读取数据</h3>
<p>前述都是基于 reader 只能读取 closed 的 ledger 的前提。但是 reader完全有可能需要读取 open 的ledger（废话。。。），因此 BK 提供了绕过了 recovery 流程的读取API。在这个API 中，为了防止 reader 读取到 transient entry（只在 quorum 中复制了一部分，关闭 ledger 后可能会被 trim 掉的 entry），reader会向bookie 查询 ledger 的 LAC，读取 LAC 以前的 entry 是安全的，因为他们都已经被完整地复制了。</p>
<p>Ledger device：第一版不同的 ledger 有不同的文件，后来改为一个（类似RocketMQ的CommitLog），成为entry log。原因是多个文件的随机写入带来的磁盘寻道、Page cache 的竞争大大降低了写入吞吐。不同 ledger 的 entry 都存储在一个 entry log 中。</p>
<p><img src="https://cdn.jsdelivr.net/gh/RayneHwang/img-repo/bookkeeper-write.svg?" alt=""></p>
<div style="text-align: center;">
<i>
 Journal to Ledger Log 
</i>
</div>
<p>对于每个ledger，bookie 在 ledger device 上还维护了一个索引，并且把这个索引 映射 到内存，降低索引构建导致的 IO 开销。</p>
<p>Ledger 的设计主要针对写为主的流量。读的场景下，如果命中了内存中的ledger index，那么只需要一次磁盘 IO，否则需要先从 Ledger index文件找到 entry 所在 entry log 中的位置，然后再去 entry log 中读取entry内容。</p>
<h2 id="源码分析">源码分析</h2>
<h3 id="entry-的写入">Entry 的写入</h3>
<p><img src="https://huanglei-rocks-blog.oss-cn-shanghai.aliyuncs.com/blog/entry-write-diagram.png" alt="entry-write-diagram.png"></p>
<div style="text-align: center;">
<i>
 Entry 写入的流程 
</i>
</div>
<h3 id="entry-的读取">Entry 的读取</h3>
<p>还是根据 write set 找到负责 entry 的 bookie 列表，然后向这些 bookie 发送读取请求。</p>
<p>Entry 读取的时候可能存在一种特殊情况：读取的 entry 范围一jnkmlxc部分落在一个 ensemble，一部分落在另一个 ensemble，比如下面图中的情况。</p>
<p><img src="https://huanglei-rocks-blog.oss-cn-shanghai.aliyuncs.com/blog/20220228234606.png" alt="entry scatter"></p>
<div style="text-align: center;">
<i>
 尝试读取散落在不同 ensemble 的 entry 
</i>
</div>
<p>为了处理读取散落在不同 ensemble 的 entry 的情况，BookKeeper 每次读取 entry 前都会判断所读取的 entry id 是否出现 ensemble change。</p>
<p><img src="https://cdn.jsdelivr.net/gh/RayneHwang/img-repo/Bookkeeper.drawio.svg?" alt=""></p>
<div style="text-align: center;">
<i>
 Entry 读取的主流程代码 
</i>
</div>
<p>为了避免部分慢节点导致延迟升高，提升读取的性能，BookKeeper 客户端还采用了 speculative read（推测读取）的方式，如果当前读取的 bookie 没有在特定时间内返回数据，那么客户端会立刻尝试向另一个 bookie 发送读取请求，并同时等待两个 bookie 的响应。具体可见 <a href="https://bookkeeper.apache.org/docs/4.5.0/api/javadoc/org/apache/bookkeeper/client/DefaultSpeculativeRequestExecutionPolicy.html">DefaultSpeculativeRequestExecutionPolicy</a>.</p>
]]></content>
		</item>
		
		<item>
			<title>LSM Tree 笔记</title>
			<link>https://huanglei.rocks/posts/note-on-lsmt/</link>
			<pubDate>Thu, 10 Feb 2022 22:34:39 +0800</pubDate>
			
			<guid>https://huanglei.rocks/posts/note-on-lsmt/</guid>
			<description>写入（Write path）   先从磁盘（HDD）写入的特性引入 append-only 的 WAL。
  对于 KV 结构，如果写入是 append only的，那么就需要合并，不然读取性能太差。
  单文件合并性能差，因此需要按阈值切分为多个小文件，通过归并排序的思路优化合并的效率。
  多路归并要求每个文件有序，为了保证每个文件有序，就需要，数据写入的时候，不直接把 operation 直接写入到磁盘，而是先在内存缓存一段时间，并且在内存排好序，然后再一次把整个文件 flush 到磁盘。
 内存有序的数据结构：跳表、红黑树、B+ 树 buffer 在内存的数据丢了怎么办？先写 redo log    有序数据结构  RocksDB 的数据结构比较：选择跳表的原因是跳表支持并发插入。
 LSMT 的数据分类
 内存数据：MemTable 磁盘数据：SSTable（Sorted Sequence Table） 日志：redo log  内存数据组织 内存的数据需要保证有序，同时支持高性能的插入和查找。
 ART：自适应基树（比如 Bitcask 采用）； SkipList：LevelDB、RocksDB 等。  SSTable 文件格式 按 Block 进行存储，可以参考 LevelDB 和 RocksDB 的 SST 文件的格式。</description>
			<content type="html"><![CDATA[<h2 id="写入write-path">写入（Write path）</h2>
<ul>
<li>
<p>先从磁盘（HDD）写入的特性引入 append-only 的 WAL。</p>
</li>
<li>
<p>对于 KV 结构，如果写入是 append only的，那么就需要合并，不然读取性能太差。</p>
</li>
<li>
<p>单文件合并性能差，因此需要按阈值切分为多个小文件，通过归并排序的思路优化合并的效率。</p>
</li>
<li>
<p>多路归并要求每个文件有序，为了保证每个文件有序，就需要，数据写入的时候，不直接把 operation 直接写入到磁盘，而是先在内存缓存一段时间，并且在内存排好序，然后再一次把整个文件 flush 到磁盘。</p>
<ul>
<li>内存有序的数据结构：跳表、红黑树、B+ 树</li>
<li>buffer 在内存的数据丢了怎么办？先写 redo log</li>
</ul>
</li>
</ul>
<h2 id="有序数据结构">有序数据结构</h2>
<p><img src="https://gw.alipayobjects.com/zos/antfincdn/V8oKiYS5z/1639280343.png" alt=""></p>
<blockquote>
<p><a href="https://github.com/facebook/rocksdb/wiki/MemTable">RocksDB 的数据结构比较</a>：选择跳表的原因是跳表支持并发插入。</p>
</blockquote>
<p>LSMT 的数据分类</p>
<ul>
<li>内存数据：MemTable</li>
<li>磁盘数据：SSTable（Sorted Sequence Table）</li>
<li>日志：redo log</li>
</ul>
<h2 id="内存数据组织">内存数据组织</h2>
<p>内存的数据需要保证有序，同时支持高性能的插入和查找。</p>
<ul>
<li>ART：自适应基树（比如 Bitcask 采用）；</li>
<li>SkipList：LevelDB、RocksDB 等。</li>
</ul>
<h2 id="sstable-文件格式">SSTable 文件格式</h2>
<p>按 Block 进行存储，可以参考 LevelDB 和 RocksDB 的 SST 文件的格式。</p>
<h2 id="合并策略">合并策略</h2>
<ul>
<li>
<p>分级合并（Leveling Merge Policy）</p>
<ul>
<li>每一级都有且只有一个文件</li>
</ul>
</li>
<li>
<p>分层合并 (Tiering Merge Policy)</p>
<ul>
<li>每一级有多个小文件，每个小文件中的 key 不重叠（LevelDB 和 RocksDB采用，尽管他们称自己为 leveling merge）</li>
</ul>
</li>
<li>
<p>合并时间：定时合并、达到阈值合并。</p>
</li>
</ul>
<h2 id="读取read-path">读取（Read path）</h2>
<p>核心原则：先热后冷读取最新的数据，一旦读取到就停止。</p>
<ul>
<li>优先读取 MemTable，然后读取 SSTable</li>
</ul>
<h3 id="读取的优化">读取的优化</h3>
<ul>
<li>通过 BloomFilter 优化不存在的数据的判断</li>
<li>SSTable 分区</li>
<li>压缩</li>
</ul>
<h2 id="lsmt-的问题">LSMT 的问题</h2>
<h3 id="读放大">读放大</h3>
<p>一次 key 的读取需要由新到旧依次读取，涉及到不止一次IO，在范围查询的时候尤其明显。</p>
<h3 id="写放大">写放大</h3>
<p>后台合并（compaction）导致一个文件可能需要被写入多次。</p>
<h3 id="空间放大">空间放大</h3>
<p>Append-only 导致过期数据一致存在，直到被清理</p>
<h2 id="总结">总结</h2>
<ul>
<li>写放大：尽管 LSM Tree 通过顺序 IO 提供了更大的写入吞吐，但是写入放大的问题会争抢正常写入的磁盘带宽，从而降低性能和磁盘的使用寿命。</li>
<li>合并：后台的合并操作导致 write stall</li>
<li>新硬件：Remote compaction，Compaction offloading，AEP</li>
</ul>
<p>索引存储</p>
<ul>
<li>索引不存储
<ul>
<li>buntdb：每次重启重建</li>
</ul>
</li>
<li>索引存储
<ul>
<li>分离存储
<ul>
<li>Bitcask</li>
<li>MySQL MyISAM</li>
</ul>
</li>
<li>一起存储
<ul>
<li>BoltDB</li>
<li>MySQL Innodb</li>
<li>LevelDB (SStable)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="reference">Reference</h1>
<ul>
<li><a href="https://www.youtube.com/watch?v=adamqSuHHck&amp;ab_channel=TalkGo">理论结合实践详解 lsm 树存储引擎（bitcask、moss、leveldb 等）</a></li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>使用 GitHub Issue 作为 Hugo 的评论系统</title>
			<link>https://huanglei.rocks/posts/hugo-comment-with-github-issues/</link>
			<pubDate>Thu, 10 Feb 2022 15:07:10 +0800</pubDate>
			
			<guid>https://huanglei.rocks/posts/hugo-comment-with-github-issues/</guid>
			<description>安装 Octomments 按照 Octomments 的介绍，将 Octomments 安装到您的 GitHub 账户，确保它拥有访问您的目标 repo 的 issue 的权限。
配置 GitHub issue 在配置文件中增加配置项：
 comment.owner：Issue repo 的拥有者 comment.repo：Issue repo 的名字  配置 Comment 组件 在您的博客站点根目录下的layouts/partials/comments.html 模板中增加：
{{ if .Params.issueNumber -}} &amp;lt;link href=&amp;#34;https://unpkg.com/octomments/build/ocs-ui.min.css&amp;#34; rel=&amp;#34;stylesheet&amp;#34;&amp;gt; &amp;lt;div id=&amp;#34;comments&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;script src=&amp;#34;https://unpkg.com/octomments/build/ocs.min.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;script&amp;gt; Octomments({ github: { owner: &amp;#39;{{ $.Site.Params.comment.owner }}&amp;#39;, repo: &amp;#39;{{ $.Site.Params.comment.repo }}&amp;#39;, }, issueNumber: {{ .Params.issueNumber }}, renderer: [OctommentsRenderer, &amp;#39;#comments&amp;#39;] }).init(); &amp;lt;/script&amp;gt; {{ end }} 配置需要评论的文章 在文章的 metadata 章节加入创建的 issue 的 issue number，如本文的 metadata：</description>
			<content type="html"><![CDATA[<h1 id="安装-octomments">安装 Octomments</h1>
<p>按照 <a href="https://ocs.vercel.app/">Octomments</a> 的介绍，将 Octomments 安装到您的 GitHub 账户，确保它拥有访问您的目标 repo 的 issue 的权限。</p>
<h1 id="配置-github-issue">配置 GitHub issue</h1>
<p>在配置文件中增加配置项：</p>
<ul>
<li><code>comment.owner</code>：Issue repo 的拥有者</li>
<li><code>comment.repo</code>：Issue repo 的名字</li>
</ul>
<h1 id="配置-comment-组件">配置 Comment 组件</h1>
<p>在您的博客站点根目录下的<code>layouts/partials/comments.html</code> 模板中增加：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-html" data-lang="html"><span class="line"><span class="cl">{{ if .Params.issueNumber -}}
</span></span><span class="line"><span class="cl"><span class="p">&lt;</span><span class="nt">link</span> <span class="na">href</span><span class="o">=</span><span class="s">&#34;https://unpkg.com/octomments/build/ocs-ui.min.css&#34;</span> <span class="na">rel</span><span class="o">=</span><span class="s">&#34;stylesheet&#34;</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;</span><span class="nt">div</span> <span class="na">id</span><span class="o">=</span><span class="s">&#34;comments&#34;</span><span class="p">&gt;&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;</span><span class="nt">script</span> <span class="na">src</span><span class="o">=</span><span class="s">&#34;https://unpkg.com/octomments/build/ocs.min.js&#34;</span><span class="p">&gt;&lt;/</span><span class="nt">script</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">&lt;</span><span class="nt">script</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="nx">Octomments</span><span class="p">({</span>
</span></span><span class="line"><span class="cl">    <span class="nx">github</span><span class="o">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">owner</span><span class="o">:</span> <span class="s1">&#39;{{ $.Site.Params.comment.owner }}&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="nx">repo</span><span class="o">:</span> <span class="s1">&#39;{{ $.Site.Params.comment.repo }}&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="p">},</span>
</span></span><span class="line"><span class="cl">    <span class="nx">issueNumber</span><span class="o">:</span> <span class="p">{{</span> <span class="p">.</span><span class="nx">Params</span><span class="p">.</span><span class="nx">issueNumber</span> <span class="p">}},</span>
</span></span><span class="line"><span class="cl">    <span class="nx">renderer</span><span class="o">:</span> <span class="p">[</span><span class="nx">OctommentsRenderer</span><span class="p">,</span> <span class="s1">&#39;#comments&#39;</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">  <span class="p">}).</span><span class="nx">init</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;/</span><span class="nt">script</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">{{ end }}
</span></span></code></pre></div><h1 id="配置需要评论的文章">配置需要评论的文章</h1>
<p>在文章的 metadata 章节加入创建的 issue 的 issue number，如本文的 metadata：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="cl"><span class="nn">---</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">title</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;使用 GitHub Issue 作为 Hugo 的评论系统&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">date</span><span class="p">:</span><span class="w"> </span><span class="ld">2022-02-10T15:07:10</span><span class="m">+08</span><span class="p">:</span><span class="m">00</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">draft</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">toc</span><span class="p">:</span><span class="w"> </span><span class="kc">false</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">issueNumber</span><span class="p">:</span><span class="w"> </span><span class="m">3</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">images</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">tags</span><span class="p">:</span><span class="w"> 
</span></span></span><span class="line"><span class="cl"><span class="w">  </span>- <span class="l">Hugo</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span>- <span class="l">Github</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nn">---</span><span class="w">
</span></span></span></code></pre></div><p>这样本文的末尾就会出现一个评论栏啦，所有对本文的评论都会同步到 GitHub 的 issue 中。</p>
]]></content>
		</item>
		
		<item>
			<title>Rust 对象安全详解</title>
			<link>https://huanglei.rocks/posts/object-safety/</link>
			<pubDate>Thu, 09 Dec 2021 21:57:33 +0800</pubDate>
			
			<guid>https://huanglei.rocks/posts/object-safety/</guid>
			<description>Rust 的 RFC 上只给出了 object-safety 的定义，但是没有解释为何在满足这些条件的时候 trait 是 object safe 的，以及为啥需要 object safety，这反而是初学者最为困惑的点。
为什么需要 object safety？ Rust 通过 trait object 提供了类型擦除、动态分派的能力，但是这个能力是有限制的，不是所有的 trait 都能自动生成实现。 Trait object 本质上是对某个 trait 的自动默认实现，包括一个数据区和一个方法表。Object-safety 就是为了保证 Rust 编译器能够为某个 trait 生成合法自动实现。
 Trait object 的内存布局    Where Self Meets Sized: Revisiting Object Safety
 首先是关于 trait 的 object safety，一个 trait 是对象安全的，当且仅当它满足以下所有条件：
 trait 的类型不能限定为 Self: Sized1️⃣； trait 中所定义的所有方法都是 object-safe 的2️⃣；  接下来是关于方法的 object safety：一个方法是对象安全的，当且仅当这个方法满足下面任意一个特性：
 方法 receiver 的类型限定是 Self: Sized3️⃣ ；或者 满足以下所有条件：  方法不能有泛型参数4️⃣；且 receiver 类型必须是 Self 或者可以解引用为 Self 的引用类型5️⃣ 。目前只包括self/ &amp;amp;self / &amp;amp;mut self/ self: Box&amp;lt;Self&amp;gt;。以后可能也会扩展到 Rc&amp;lt;Self&amp;gt;等等。 Self类型只能用作 receiver 6️⃣     1️⃣ 也就是说，如下的 trait 是不能用作 trait object 的。</description>
			<content type="html"><![CDATA[<p>Rust 的 <a href="https://rust-lang.github.io/rfcs/0255-object-safety.html">RFC</a> 上只给出了 object-safety 的定义，但是没有解释为何在满足这些条件的时候 trait 是 object safe 的，以及为啥需要 object safety，这反而是初学者最为困惑的点。</p>
<h1 id="为什么需要-object-safety">为什么需要 object safety？</h1>
<p>Rust 通过 trait object 提供了类型擦除、动态分派的能力，但是这个能力是有限制的，不是所有的 trait 都能自动生成实现。
<strong>Trait object 本质上是对某个 trait 的自动默认实现，包括一个数据区和一个方法表。<u>Object-safety 就是为了保证 Rust 编译器能够为某个 trait 生成合法自动实现。</u></strong></p>
<p><img src="https://gw.alipayobjects.com/zos/antfincdn/QAgzwRCoT/1644416416.png" alt="trait-object.png"></p>
<div style="text-align: center;">
<i>
 Trait object 的内存布局 
</i>
</div>
<blockquote>
<p><a href="https://huonw.github.io/blog/2015/05/where-self-meets-sized-revisiting-object-safety/">Where Self Meets Sized: Revisiting Object Safety</a></p>
</blockquote>
<p>首先是关于 trait 的 object safety，一个 trait 是对象安全的，当且仅当它<strong>满足以下<u>所有</u>条件</strong>：</p>
<ul>
<li>trait 的类型不能限定为 <code>Self: Sized</code><sup>1️⃣</sup>；</li>
<li>trait 中所定义的所有方法都是 object-safe 的<sup>2️⃣</sup>；</li>
</ul>
<p>接下来是关于方法的 object safety：一个方法是对象安全的，当且仅当这个方法<strong>满足下面<u>任意一个</u>特性</strong>：</p>
<ul>
<li>方法 receiver 的类型限定是 <code>Self: Sized</code><sup>3️⃣ </sup>；或者</li>
<li>满足以下所有条件：
<ul>
<li>方法不能有泛型参数<sup>4️⃣</sup>；且</li>
<li>receiver 类型必须是 Self 或者可以解引用为 Self 的引用类型<sup>5️⃣ </sup>。目前只包括<code>self</code>/ <code>&amp;self</code> / <code>&amp;mut self</code>/ <code>self: Box&lt;Self&gt;</code>。以后可能也会扩展到 <code>Rc&lt;Self&gt;</code>等等。</li>
<li><code>Self</code>类型只能用作 receiver <sup>6️⃣ </sup></li>
</ul>
</li>
</ul>
<p>1️⃣   也就是说，如下的 trait 是不能用作 trait object 的。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">trait</span><span class="w"> </span><span class="n">Test</span>: <span class="nb">Sized</span> <span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">	</span><span class="k">fn</span> <span class="nf">some_method</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>为什么trait 的方法的 receiver 不能限定为 <code>Self: Sized</code>？因为 trait object 本身是动态分派的，编译期无法确定 trait object 的大小。如果这个时候 trait object 的方法又要求 Self 大小可确定，那就互相矛盾了。
需要注意的是，trait object 自身的大小是可确定的，因为其只包括指向数据的指针和指向 vtable 的指针而已。</p>
<p>2️⃣   要求 trait 所有的方法都是对象安全的也是为了确保动态分派的时候能够正确从 vtable 中找到方法进行调用。</p>
<p>3️⃣   由于 trait object 自身是 Unsized，如果方法限定了<code>Self: Sized</code>，那么一定无法通过 trait object 去调用。也就不会导致动态分派的 object safety 问题，因此一个限定了 <code>Self: Sized</code>的 trait 方法也被认为是 object-safe 的。</p>
<blockquote>
<ul>
<li><a href="https://stackoverflow.com/questions/42620022/why-does-a-generic-method-inside-a-trait-require-trait-object-to-be-sized">Why does a generic method inside a trait require trait object to be sized? - Stack Overflow</a></li>
<li><a href="https://github.com/rust-lang/rust/issues/22031">A method marked where Self: Sized on a trait should not be considered during object safety checks #22031</a></li>
</ul>
</blockquote>
<p>4️⃣   如果方法不限定 <code>Self: Sized</code> ，就意味着那么这个方法首先不能有泛型参数。如果有泛型参数，那么 vtable 中的方法列表大小是难以确定的。当然如果非要做，在编译期，rust 编译器可以拿到 trait 的所有具体实现，然后为每一个具体实现在 vtable 生成一个特化的方法项。但是首先这会大大降低编译速度，其次也会引入极大的复杂性。因此 Rust 的 trait object 直接禁止了这种使用场景。</p>
<blockquote>
<p><a href="https://stackoverflow.com/questions/67767207/why-are-trait-methods-with-generic-type-parameters-object-unsafe">Why are trait methods with generic type parameters object-unsafe?</a></p>
</blockquote>
<p>5️⃣   如果方法没有 receiver，那么使用 trait object 毫无意义，因为这个方法的调用根本不需要 trait object 里面的 data 指针。</p>
<p>6️⃣   假设 trait 定义了这么一个方法：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">trait</span><span class="w"> </span><span class="n">Test</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">	</span><span class="k">fn</span> <span class="nf">duplicate</span><span class="p">(</span><span class="bp">self</span>: <span class="nc">Self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>那么这个 trait 的 duplicate 方法要求返回的类型和方法 receiver 的类型是一样的。如果 Trait 是静态分派，那么在编译器就可以确定所有可能的方法签名。比如结构体 A、B 实现了 Test trait，那么 duplicate 方法所有可能的签名是：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">fn</span> <span class="nf">duplicate</span><span class="p">(</span><span class="bp">self</span>: <span class="nc">A</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">A</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">fn</span> <span class="nf">duplicate</span><span class="p">(</span><span class="bp">self</span>: <span class="nc">B</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">B</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><p>而在动态分派下，从一个 trait object 发起方法的调用，也就无法在编译期约束不同位置的 Self 类型都是一致的，完全有可能出现下面的情况：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">fn</span> <span class="nf">duplicate</span><span class="p">(</span><span class="bp">self</span>: <span class="nc">B</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">A</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><p>显然这不是对 <code>Test</code> 这个 trait 的一个合法实现。</p>
<ul>
<li><a href="https://rust-lang.github.io/rfcs/0255-object-safety.html">https://rust-lang.github.io/rfcs/0255-object-safety.html</a></li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>Paxos Made Simple 笔记 (WIP)</title>
			<link>https://huanglei.rocks/posts/notes-on-paxos-made-simple/</link>
			<pubDate>Mon, 14 Jun 2021 11:24:18 +0800</pubDate>
			
			<guid>https://huanglei.rocks/posts/notes-on-paxos-made-simple/</guid>
			<description>关于 P2c P2c 是 P2b 的充分不必要条件，why？
  P2b: If a proposal with value v is chosen, then every higher-numbered proposal issued by any proposer has value v. P2c: For any v and n, if a proposal with value v and number n is issued, then there is a set S consisting of a majority of acceptors such that either  (a) no acceptor in S has accepted any proposal numbered less than n, or (b) v is the value of the highest-numbered proposal among all proposals numbered less than n accepted by the acceptors in S.</description>
			<content type="html"><![CDATA[<h1 id="关于-p2c">关于 P2c</h1>
<p>P2c 是 P2b 的充分不必要条件，why？</p>
<blockquote>
<ul>
<li>P2b: If a proposal with value v is chosen, then every higher-numbered proposal issued by any proposer has value <code>v</code>.</li>
<li>P2c: For any <code>v</code> and <code>n</code>, if a proposal with value <code>v</code> and number <code>n</code> is issued, then there is a set S consisting of a majority of acceptors such that either
<ul>
<li>(a) no acceptor in S has accepted any proposal numbered less than <code>n</code>, or</li>
<li>(b) <code>v</code> is the value of the highest-numbered proposal among all proposals numbered less than <code>n</code> accepted by the acceptors in S.</li>
</ul>
</li>
</ul>
</blockquote>
<p>已知 proposal:<code>(m,v)</code>被选中，要满足任意 proposer 提出序号 n （n &gt; m）的 proposal 的值都是 <code>v</code>，那么只要满足条件：<u> $ \forall i\in [m,\ n-1]$ ，有 proposal <code>i</code> 的值是 <code>v</code> 1</u>，那么根据数学归纳法，proposal <code>n</code>的值也必然是 <code>v</code>。</p>
<p>1: 是附加假设，我们需要根据这个附加假设去约束 proposer 的行为，从而使得 P2b 能够被满足。下面就需要解释这个附加假设对 proposer 的行为做出了什么样的约束。</p>
<p>由于 <code>(m,v)</code>已经被选中了，那就意味着存在一个 acceptor 的集合 C 满足任意 C 中的 acceptor 都 accept 了<code>(m,v)</code>，再加上我们需要让附加假设（满足 $i\in [m,\ n-1]$ ，有 proposal <code>i</code> 的值是 <code>v</code>）成立，
这就意味着所谓的 C-condition 2 ，对于 accept 了 <code>(m,v)</code> 的 acceptor 集合 C，满足：</p>
<ul>
<li>(1)  C 中的所有 acceptor 都 accept 了 $[m,\ n-1]$ 中的一个 proposal（因为至少有<code>m</code>已经被 C 中的所有 acceptor 给 accept 了）</li>
<li>(2) $[m,\ n-1]$ 中所有的被任意 acceptor 所 accept 的 proposal 的值都是 <code>v</code>（注意，这里约束的对象从 proposer 变成了 acceptor，实际上 narrow down 了，因为是非拜占庭问题，所有被 acceptor 所 accept 的值都需要 proposer 提出）。</li>
</ul>
<p>那么只要 proposer 满足 P2c，就能满足所谓的 C-condition，从而实现 P2c -&gt; C-condidtion -&gt; 附加假设 1-&gt; P2b 的证明路径。</p>
<blockquote>
<p>为什么 P2c 可以保证 C-condidition？
P2c 约束了 proposer 每次提案之前先要知道 majority 的情况，由于<code>(m,v)</code>已经 chosen，因此符合 P2c 的 proposer 在提出 m+1 的时候，提案的值必然是 m（highest accepted proposal）的值 v，m+2、m+3 直到 n-1 都是这样，从而可以保证 C-condition 的 (2)，</p>
</blockquote>
<p>因此 P2b 到 P2c 实际上是让约束逐步可实现化的 narrow down，因为让 proposer 去感知 acceptor 的状态是更容易实现的。</p>
<blockquote>
<p>Learning about proposals already accepted is easy enough; predicting future acceptances is hard. Instead of trying to predict the future, the proposer controls it by extracting a promise that there won’t be any such acceptances.</p>
</blockquote>
]]></content>
		</item>
		
		<item>
			<title>Add MathJax and Graphviz support for HUGO</title>
			<link>https://huanglei.rocks/posts/add-math-and-dot-for-hugo/</link>
			<pubDate>Sun, 12 Apr 2020 14:22:22 +0800</pubDate>
			
			<guid>https://huanglei.rocks/posts/add-math-and-dot-for-hugo/</guid>
			<description>Get into your theme folder
  Find some directory named layouts/posts/single.html
  Inside the {{ define main }} block, paste following snippets
  {{ if .Params.viz }} &amp;lt;script type=&amp;#34;text/javascript&amp;#34; src=&amp;#34;https://cdn.bootcss.com/viz.js/1.8.2/viz.js&amp;#34;&amp;gt; &amp;lt;/script&amp;gt; &amp;lt;script type=&amp;#34;text/javascript&amp;#34;&amp;gt; (function(){ var vizPrefix = &amp;#34;language-viz-&amp;#34;; Array.prototype.forEach.call(document.querySelectorAll(&amp;#34;[class^=&amp;#34; + vizPrefix + &amp;#34;]&amp;#34;), function(x){ var engine; x.getAttribute(&amp;#34;class&amp;#34;).split(&amp;#34; &amp;#34;).forEach(function(cls){ if (cls.startsWith(vizPrefix)) { engine = cls.substr(vizPrefix.length); } }); var image = new DOMParser().parseFromString(Viz(x.innerText, {format:&amp;#34;svg&amp;#34;, engine:engine}), &amp;#34;image/svg+xml&amp;#34;); x.parentNode.insertBefore(image.documentElement, x); x.</description>
			<content type="html"><![CDATA[<ol>
<li>
<p>Get into your theme folder</p>
</li>
<li>
<p>Find some directory named <code>layouts/posts/single.html</code></p>
</li>
<li>
<p>Inside the <code>{{ define main }}</code> block, paste following snippets</p>
</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="p">{{</span> <span class="k">if</span> <span class="p">.</span><span class="nx">Params</span><span class="p">.</span><span class="nx">viz</span> <span class="p">}}</span>
</span></span><span class="line"><span class="cl">  <span class="o">&lt;</span><span class="nx">script</span> <span class="nx">type</span><span class="o">=</span><span class="s2">&#34;text/javascript&#34;</span> <span class="nx">src</span><span class="o">=</span><span class="s2">&#34;https://cdn.bootcss.com/viz.js/1.8.2/viz.js&#34;</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="err">/script&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="o">&lt;</span><span class="nx">script</span> <span class="nx">type</span><span class="o">=</span><span class="s2">&#34;text/javascript&#34;</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="p">(</span><span class="kd">function</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">    <span class="kd">var</span> <span class="nx">vizPrefix</span> <span class="o">=</span> <span class="s2">&#34;language-viz-&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nb">Array</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">forEach</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nb">document</span><span class="p">.</span><span class="nx">querySelectorAll</span><span class="p">(</span><span class="s2">&#34;[class^=&#34;</span> <span class="o">+</span> <span class="nx">vizPrefix</span> <span class="o">+</span> <span class="s2">&#34;]&#34;</span><span class="p">),</span> <span class="kd">function</span><span class="p">(</span><span class="nx">x</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">      <span class="kd">var</span> <span class="nx">engine</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="nx">x</span><span class="p">.</span><span class="nx">getAttribute</span><span class="p">(</span><span class="s2">&#34;class&#34;</span><span class="p">).</span><span class="nx">split</span><span class="p">(</span><span class="s2">&#34; &#34;</span><span class="p">).</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">cls</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="nx">cls</span><span class="p">.</span><span class="nx">startsWith</span><span class="p">(</span><span class="nx">vizPrefix</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="nx">engine</span> <span class="o">=</span> <span class="nx">cls</span><span class="p">.</span><span class="nx">substr</span><span class="p">(</span><span class="nx">vizPrefix</span><span class="p">.</span><span class="nx">length</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="p">});</span>
</span></span><span class="line"><span class="cl">      <span class="kd">var</span> <span class="nx">image</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">DOMParser</span><span class="p">().</span><span class="nx">parseFromString</span><span class="p">(</span><span class="nx">Viz</span><span class="p">(</span><span class="nx">x</span><span class="p">.</span><span class="nx">innerText</span><span class="p">,</span> <span class="p">{</span><span class="nx">format</span><span class="o">:</span><span class="s2">&#34;svg&#34;</span><span class="p">,</span> <span class="nx">engine</span><span class="o">:</span><span class="nx">engine</span><span class="p">}),</span> <span class="s2">&#34;image/svg+xml&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="nx">x</span><span class="p">.</span><span class="nx">parentNode</span><span class="p">.</span><span class="nx">insertBefore</span><span class="p">(</span><span class="nx">image</span><span class="p">.</span><span class="nx">documentElement</span><span class="p">,</span> <span class="nx">x</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="nx">x</span><span class="p">.</span><span class="nx">style</span><span class="p">.</span><span class="nx">display</span> <span class="o">=</span> <span class="s1">&#39;none&#39;</span>
</span></span><span class="line"><span class="cl">      <span class="nx">x</span><span class="p">.</span><span class="nx">parentNode</span><span class="p">.</span><span class="nx">style</span><span class="p">.</span><span class="nx">backgroundColor</span> <span class="o">=</span> <span class="s2">&#34;white&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="p">});</span>
</span></span><span class="line"><span class="cl">  <span class="p">})();</span>
</span></span><span class="line"><span class="cl">  <span class="o">&lt;</span><span class="err">/script&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">{{</span> <span class="nx">end</span> <span class="p">}}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">{{</span> <span class="k">if</span>  <span class="p">.</span><span class="nx">Params</span><span class="p">.</span><span class="nx">math</span>   <span class="p">}}</span>
</span></span><span class="line"><span class="cl">  <span class="o">&lt;</span><span class="nx">script</span> <span class="nx">type</span><span class="o">=</span><span class="s2">&#34;text/javascript&#34;</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nb">window</span><span class="p">.</span><span class="nx">MathJax</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">tex2jax</span><span class="o">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">inlineMath</span><span class="o">:</span> <span class="p">[[</span><span class="s1">&#39;$&#39;</span><span class="p">,</span><span class="s1">&#39;$&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;\\(&#39;</span><span class="p">,</span><span class="s1">&#39;\\)&#39;</span><span class="p">]],</span>
</span></span><span class="line"><span class="cl">        <span class="nx">displayMath</span><span class="o">:</span> <span class="p">[[</span><span class="s1">&#39;$$&#39;</span><span class="p">,</span><span class="s1">&#39;$$&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;\[&#39;</span><span class="p">,</span><span class="s1">&#39;\]&#39;</span><span class="p">]],</span>
</span></span><span class="line"><span class="cl">        <span class="nx">processEscapes</span><span class="o">:</span> <span class="kc">true</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="nx">processEnvironments</span><span class="o">:</span> <span class="kc">true</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="nx">skipTags</span><span class="o">:</span> <span class="p">[</span><span class="s1">&#39;script&#39;</span><span class="p">,</span> <span class="s1">&#39;noscript&#39;</span><span class="p">,</span> <span class="s1">&#39;style&#39;</span><span class="p">,</span> <span class="s1">&#39;textarea&#39;</span><span class="p">,</span> <span class="s1">&#39;pre&#39;</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">        <span class="nx">TeX</span><span class="o">:</span> <span class="p">{</span> <span class="nx">equationNumbers</span><span class="o">:</span> <span class="p">{</span> <span class="nx">autoNumber</span><span class="o">:</span> <span class="s2">&#34;AMS&#34;</span> <span class="p">},</span>
</span></span><span class="line"><span class="cl">          <span class="nx">extensions</span><span class="o">:</span> <span class="p">[</span><span class="s2">&#34;AMSmath.js&#34;</span><span class="p">,</span> <span class="s2">&#34;AMSsymbols.js&#34;</span><span class="p">,</span> <span class="s2">&#34;color.js&#34;</span><span class="p">]</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="p">},</span>
</span></span><span class="line"><span class="cl">      <span class="nx">AuthorInit</span><span class="o">:</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">MathJax</span><span class="p">.</span><span class="nx">Hub</span><span class="p">.</span><span class="nx">Register</span><span class="p">.</span><span class="nx">StartupHook</span><span class="p">(</span><span class="s2">&#34;Begin&#34;</span><span class="p">,</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="nx">MathJax</span><span class="p">.</span><span class="nx">Hub</span><span class="p">.</span><span class="nx">Queue</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="kd">var</span> <span class="nx">all</span> <span class="o">=</span> <span class="nx">MathJax</span><span class="p">.</span><span class="nx">Hub</span><span class="p">.</span><span class="nx">getAllJax</span><span class="p">(),</span> <span class="nx">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">for</span><span class="p">(</span><span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">all</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">              <span class="nx">all</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">SourceElement</span><span class="p">().</span><span class="nx">parentNode</span><span class="p">.</span><span class="nx">className</span> <span class="o">+=</span> <span class="s1">&#39; has-jax&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">          <span class="p">})</span>
</span></span><span class="line"><span class="cl">        <span class="p">});</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">};</span>
</span></span><span class="line"><span class="cl">  <span class="o">&lt;</span><span class="err">/script&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="o">&lt;</span><span class="nx">script</span>  <span class="nx">type</span><span class="o">=</span><span class="s2">&#34;text/javascript&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="nx">src</span><span class="o">=</span><span class="s2">&#34;https://cdn.bootcss.com/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML&#34;</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="o">&lt;</span><span class="err">/script&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">{{</span> <span class="nx">end</span> <span class="p">}}</span>
</span></span></code></pre></div><ol start="4">
<li>Create some posts and add following config inside front-matter</li>
</ol>
<pre tabindex="0"><code>viz: true
math: true
</code></pre><p>And try some graphviz and mathjax stuff!</p>
<p><img src="/images/mathjax-dot-demo.png" alt="mathjax-dot-demo"></p>
<blockquote>
<p>You may check the demo <a href="/posts/math-and-dot-demo">here</a></p>
</blockquote>
]]></content>
		</item>
		
		<item>
			<title>Graphviz and mathjax demo</title>
			<link>https://huanglei.rocks/posts/math-and-dot-demo/</link>
			<pubDate>Sat, 11 Apr 2020 23:26:41 +0800</pubDate>
			
			<guid>https://huanglei.rocks/posts/math-and-dot-demo/</guid>
			<description>digraph g{ rankdir=LR; node [shape=record,width=01,height=.1]; a[label=&amp;#34;&amp;lt;1&amp;gt;Hash Table|&amp;lt;2&amp;gt;Node|&amp;lt;3&amp;gt;Node|...|&amp;lt;4&amp;gt;TreeNode&amp;#34;]; { // graph[rankdir=LR] node1[label=&amp;#34;{&amp;lt;1&amp;gt;A1|&amp;lt;2&amp;gt;A2|...|An}&amp;#34;] node2[label=&amp;#34;{&amp;lt;1&amp;gt;B1|&amp;lt;2&amp;gt;B2|...|Bn}&amp;#34;] // node3[label=&amp;#34;{&amp;lt;1&amp;gt;C1|&amp;lt;2&amp;gt;C2}&amp;#34;] subgraph cluster_treenode{ penwidth=0; node[shape=circle]; root[label=&amp;#34;&amp;#34;, style=filled,fillcolor=black,width=.2]; n1[label=&amp;#34;&amp;#34;, style=filled,fillcolor=red,width=.2] n2[label=&amp;#34;&amp;#34;, style=filled,fillcolor=black,width=.2] n3[label=&amp;#34;&amp;#34;, style=filled,fillcolor=black,width=.2] n4[label=&amp;#34;&amp;#34;, style=filled,fillcolor=red,width=.2] n5[label=&amp;#34;&amp;#34;, style=filled,fillcolor=black,width=.2] n6[label=&amp;#34;&amp;#34;, style=filled,fillcolor=black,width=.2] root-&amp;gt;n1; n1-&amp;gt;n2; n1-&amp;gt;n3; root-&amp;gt;n4; n4-&amp;gt;n5; n4-&amp;gt;n6; } } a:2:e-&amp;gt;node1:1 [style=dashed]; a:3:e-&amp;gt;node2:1; a:4:e-&amp;gt;root; // node3:d-&amp;gt;node3:sa2; } $$f(a) = \frac{1}{2\pi i} \oint\frac{f(z)}{z-a}dz$$</description>
			<content type="html"><![CDATA[<pre tabindex="0"><code class="language-viz-dot" data-lang="viz-dot">digraph g{
    rankdir=LR;
    node [shape=record,width=01,height=.1];
	a[label=&#34;&lt;1&gt;Hash Table|&lt;2&gt;Node|&lt;3&gt;Node|...|&lt;4&gt;TreeNode&#34;];
    {
        // graph[rankdir=LR]    
        node1[label=&#34;{&lt;1&gt;A1|&lt;2&gt;A2|...|An}&#34;]
        node2[label=&#34;{&lt;1&gt;B1|&lt;2&gt;B2|...|Bn}&#34;]
        // node3[label=&#34;{&lt;1&gt;C1|&lt;2&gt;C2}&#34;]
        subgraph cluster_treenode{
            penwidth=0;
            node[shape=circle];
            root[label=&#34;&#34;, style=filled,fillcolor=black,width=.2];
            n1[label=&#34;&#34;, style=filled,fillcolor=red,width=.2]
            n2[label=&#34;&#34;, style=filled,fillcolor=black,width=.2]
            n3[label=&#34;&#34;, style=filled,fillcolor=black,width=.2]
            n4[label=&#34;&#34;, style=filled,fillcolor=red,width=.2]
            n5[label=&#34;&#34;, style=filled,fillcolor=black,width=.2]
            n6[label=&#34;&#34;, style=filled,fillcolor=black,width=.2]
            root-&gt;n1;
            n1-&gt;n2;
            n1-&gt;n3;
            root-&gt;n4;
            n4-&gt;n5;
            n4-&gt;n6;
        }
    }
    
    a:2:e-&gt;node1:1 [style=dashed];
    a:3:e-&gt;node2:1;    
    a:4:e-&gt;root;    

    // node3:d-&gt;node3:sa2;
}
</code></pre><p>$$f(a) = \frac{1}{2\pi i} \oint\frac{f(z)}{z-a}dz$$</p>
]]></content>
		</item>
		
	</channel>
</rss>
